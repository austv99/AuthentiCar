{"ast":null,"code":"(function (a, b) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = b() : \"function\" == typeof define && define.amd ? define(b) : a.JSBI = b();\n})(this, function () {\n  \"use strict\";\n\n  var a = Math.imul,\n      b = Math.abs,\n      c = Math.max,\n      d = Math.clz32;\n\n  class e extends Array {\n    constructor(a, b) {\n      if (a > e.__kMaxLength) throw new RangeError(\"Maximum BigInt size exceeded\");\n      super(a), this.sign = b;\n    }\n\n    static BigInt(a) {\n      var b = Math.floor,\n          c = Number.isFinite;\n\n      if (\"number\" == typeof a) {\n        if (0 === a) return e.__zero();\n        if ((0 | a) === a) return 0 > a ? e.__oneDigit(-a, !0) : e.__oneDigit(a, !1);\n        if (!c(a) || b(a) !== a) throw new RangeError(\"The number \" + a + \" cannot be converted to BigInt because it is not an integer\");\n        return e.__fromDouble(a);\n      }\n\n      if (\"string\" == typeof a) {\n        const b = e.__fromString(a);\n\n        if (null === b) throw new SyntaxError(\"Cannot convert \" + a + \" to a BigInt\");\n        return b;\n      }\n\n      if (\"boolean\" == typeof a) return !0 === a ? e.__oneDigit(1, !1) : e.__zero();\n\n      if (\"object\" == typeof a) {\n        if (a.constructor === e) return a;\n\n        const b = e.__toPrimitive(a);\n\n        return e.BigInt(b);\n      }\n\n      throw new TypeError(\"Cannot convert \" + a + \" to a BigInt\");\n    }\n\n    toDebugString() {\n      const a = [\"BigInt[\"];\n\n      for (const b of this) a.push((b ? (b >>> 0).toString(16) : b) + \", \");\n\n      return a.push(\"]\"), a.join(\"\");\n    }\n\n    toString(a = 10) {\n      if (2 > a || 36 < a) throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n      return 0 === this.length ? \"0\" : 0 == (a & a - 1) ? e.__toStringBasePowerOfTwo(this, a) : e.__toStringGeneric(this, a, !1);\n    }\n\n    static toNumber(a) {\n      const b = a.length;\n      if (0 === b) return 0;\n\n      if (1 === b) {\n        const b = a.__unsignedDigit(0);\n\n        return a.sign ? -b : b;\n      }\n\n      const c = a.__digit(b - 1),\n            f = d(c),\n            g = 32 * b - f;\n\n      if (1024 < g) return a.sign ? -Infinity : 1 / 0;\n      let h = g - 1,\n          i = c,\n          j = b - 1;\n      const k = f + 1;\n      let l = 32 === k ? 0 : i << k;\n      l >>>= 12;\n      const m = k - 12;\n      let n = 12 <= k ? 0 : i << 20 + k,\n          o = 20 + k;\n      0 < m && 0 < j && (j--, i = a.__digit(j), l |= i >>> 32 - m, n = i << m, o = m), 0 < o && 0 < j && (j--, i = a.__digit(j), n |= i >>> 32 - o, o -= 32);\n\n      const p = e.__decideRounding(a, o, j, i);\n\n      if ((1 === p || 0 === p && 1 == (1 & n)) && (n = n + 1 >>> 0, 0 == n && (l++, 0 != l >>> 20 && (l = 0, h++, 1023 < h)))) return a.sign ? -Infinity : 1 / 0;\n      const q = a.sign ? -2147483648 : 0;\n      return h = h + 1023 << 20, e.__kBitConversionInts[1] = q | h | l, e.__kBitConversionInts[0] = n, e.__kBitConversionDouble[0];\n    }\n\n    static unaryMinus(a) {\n      if (0 === a.length) return a;\n\n      const b = a.__copy();\n\n      return b.sign = !a.sign, b;\n    }\n\n    static bitwiseNot(a) {\n      return a.sign ? e.__absoluteSubOne(a).__trim() : e.__absoluteAddOne(a, !0);\n    }\n\n    static exponentiate(a, b) {\n      if (b.sign) throw new RangeError(\"Exponent must be positive\");\n      if (0 === b.length) return e.__oneDigit(1, !1);\n      if (0 === a.length) return a;\n      if (1 === a.length && 1 === a.__digit(0)) return a.sign && 0 == (1 & b.__digit(0)) ? e.unaryMinus(a) : a;\n      if (1 < b.length) throw new RangeError(\"BigInt too big\");\n\n      let c = b.__unsignedDigit(0);\n\n      if (1 === c) return a;\n      if (c >= e.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n\n      if (1 === a.length && 2 === a.__digit(0)) {\n        const b = 1 + (c >>> 5),\n              d = a.sign && 0 != (1 & c),\n              f = new e(b, d);\n\n        f.__initializeDigits();\n\n        const g = 1 << (31 & c);\n        return f.__setDigit(b - 1, g), f;\n      }\n\n      let d = null,\n          f = a;\n\n      for (0 != (1 & c) && (d = a), c >>= 1; 0 !== c; c >>= 1) f = e.multiply(f, f), 0 != (1 & c) && (null === d ? d = f : d = e.multiply(d, f));\n\n      return d;\n    }\n\n    static multiply(a, b) {\n      if (0 === a.length) return a;\n      if (0 === b.length) return b;\n      let c = a.length + b.length;\n      32 <= a.__clzmsd() + b.__clzmsd() && c--;\n      const d = new e(c, a.sign !== b.sign);\n\n      d.__initializeDigits();\n\n      for (let c = 0; c < a.length; c++) e.__multiplyAccumulate(b, a.__digit(c), d, c);\n\n      return d.__trim();\n    }\n\n    static divide(a, b) {\n      if (0 === b.length) throw new RangeError(\"Division by zero\");\n      if (0 > e.__absoluteCompare(a, b)) return e.__zero();\n\n      const c = a.sign !== b.sign,\n            d = b.__unsignedDigit(0);\n\n      let f;\n\n      if (1 === b.length && 65535 >= d) {\n        if (1 === d) return c === a.sign ? a : e.unaryMinus(a);\n        f = e.__absoluteDivSmall(a, d, null);\n      } else f = e.__absoluteDivLarge(a, b, !0, !1);\n\n      return f.sign = c, f.__trim();\n    }\n\n    static remainder(a, b) {\n      if (0 === b.length) throw new RangeError(\"Division by zero\");\n      if (0 > e.__absoluteCompare(a, b)) return a;\n\n      const c = b.__unsignedDigit(0);\n\n      if (1 === b.length && 65535 >= c) {\n        if (1 === c) return e.__zero();\n\n        const b = e.__absoluteModSmall(a, c);\n\n        return 0 === b ? e.__zero() : e.__oneDigit(b, a.sign);\n      }\n\n      const d = e.__absoluteDivLarge(a, b, !1, !0);\n\n      return d.sign = a.sign, d.__trim();\n    }\n\n    static add(a, b) {\n      const c = a.sign;\n      return c === b.sign ? e.__absoluteAdd(a, b, c) : 0 <= e.__absoluteCompare(a, b) ? e.__absoluteSub(a, b, c) : e.__absoluteSub(b, a, !c);\n    }\n\n    static subtract(a, b) {\n      const c = a.sign;\n      return c === b.sign ? 0 <= e.__absoluteCompare(a, b) ? e.__absoluteSub(a, b, c) : e.__absoluteSub(b, a, !c) : e.__absoluteAdd(a, b, c);\n    }\n\n    static leftShift(a, b) {\n      return 0 === b.length || 0 === a.length ? a : b.sign ? e.__rightShiftByAbsolute(a, b) : e.__leftShiftByAbsolute(a, b);\n    }\n\n    static signedRightShift(a, b) {\n      return 0 === b.length || 0 === a.length ? a : b.sign ? e.__leftShiftByAbsolute(a, b) : e.__rightShiftByAbsolute(a, b);\n    }\n\n    static unsignedRightShift() {\n      throw new TypeError(\"BigInts have no unsigned right shift; use >> instead\");\n    }\n\n    static lessThan(a, b) {\n      return 0 > e.__compareToBigInt(a, b);\n    }\n\n    static lessThanOrEqual(a, b) {\n      return 0 >= e.__compareToBigInt(a, b);\n    }\n\n    static greaterThan(a, b) {\n      return 0 < e.__compareToBigInt(a, b);\n    }\n\n    static greaterThanOrEqual(a, b) {\n      return 0 <= e.__compareToBigInt(a, b);\n    }\n\n    static equal(a, b) {\n      if (a.sign !== b.sign) return !1;\n      if (a.length !== b.length) return !1;\n\n      for (let c = 0; c < a.length; c++) if (a.__digit(c) !== b.__digit(c)) return !1;\n\n      return !0;\n    }\n\n    static bitwiseAnd(a, b) {\n      var _ref;\n\n      if (!a.sign && !b.sign) return e.__absoluteAnd(a, b).__trim();\n\n      if (a.sign && b.sign) {\n        const d = c(a.length, b.length) + 1;\n\n        let f = e.__absoluteSubOne(a, d);\n\n        const g = e.__absoluteSubOne(b);\n\n        return f = e.__absoluteOr(f, g, f), e.__absoluteAddOne(f, !0, f).__trim();\n      }\n\n      return a.sign && (_ref = [b, a], a = _ref[0], b = _ref[1], _ref), e.__absoluteAndNot(a, e.__absoluteSubOne(b)).__trim();\n    }\n\n    static bitwiseXor(a, b) {\n      var _ref2;\n\n      if (!a.sign && !b.sign) return e.__absoluteXor(a, b).__trim();\n\n      if (a.sign && b.sign) {\n        const d = c(a.length, b.length),\n              f = e.__absoluteSubOne(a, d),\n              g = e.__absoluteSubOne(b);\n\n        return e.__absoluteXor(f, g, f).__trim();\n      }\n\n      const d = c(a.length, b.length) + 1;\n      a.sign && (_ref2 = [b, a], a = _ref2[0], b = _ref2[1], _ref2);\n\n      let f = e.__absoluteSubOne(b, d);\n\n      return f = e.__absoluteXor(f, a, f), e.__absoluteAddOne(f, !0, f).__trim();\n    }\n\n    static bitwiseOr(a, b) {\n      var _ref3;\n\n      const d = c(a.length, b.length);\n      if (!a.sign && !b.sign) return e.__absoluteOr(a, b).__trim();\n\n      if (a.sign && b.sign) {\n        let c = e.__absoluteSubOne(a, d);\n\n        const f = e.__absoluteSubOne(b);\n\n        return c = e.__absoluteAnd(c, f, c), e.__absoluteAddOne(c, !0, c).__trim();\n      }\n\n      a.sign && (_ref3 = [b, a], a = _ref3[0], b = _ref3[1], _ref3);\n\n      let f = e.__absoluteSubOne(b, d);\n\n      return f = e.__absoluteAndNot(f, a, f), e.__absoluteAddOne(f, !0, f).__trim();\n    }\n\n    static ADD(a, b) {\n      if (a = e.__toPrimitive(a), b = e.__toPrimitive(b), \"string\" == typeof a) return \"string\" != typeof b && (b = b.toString()), a + b;\n      if (\"string\" == typeof b) return a.toString() + b;\n      if (a = e.__toNumeric(a), b = e.__toNumeric(b), e.__isBigInt(a) && e.__isBigInt(b)) return e.add(a, b);\n      if (\"number\" == typeof a && \"number\" == typeof b) return a + b;\n      throw new TypeError(\"Cannot mix BigInt and other types, use explicit conversions\");\n    }\n\n    static LT(a, b) {\n      return e.__compare(a, b, 0);\n    }\n\n    static LE(a, b) {\n      return e.__compare(a, b, 1);\n    }\n\n    static GT(a, b) {\n      return e.__compare(a, b, 2);\n    }\n\n    static GE(a, b) {\n      return e.__compare(a, b, 3);\n    }\n\n    static EQ(a, b) {\n      for (;;) {\n        if (e.__isBigInt(a)) return e.__isBigInt(b) ? e.equal(a, b) : e.EQ(b, a);\n\n        if (\"number\" == typeof a) {\n          if (e.__isBigInt(b)) return e.__equalToNumber(b, a);\n          if (\"object\" != typeof b) return a == b;\n          b = e.__toPrimitive(b);\n        } else if (\"string\" == typeof a) {\n          if (e.__isBigInt(b)) return a = e.__fromString(a), null !== a && e.equal(a, b);\n          if (\"object\" != typeof b) return a == b;\n          b = e.__toPrimitive(b);\n        } else if (\"boolean\" == typeof a) {\n          if (e.__isBigInt(b)) return e.__equalToNumber(b, +a);\n          if (\"object\" != typeof b) return a == b;\n          b = e.__toPrimitive(b);\n        } else if (\"symbol\" == typeof a) {\n          if (e.__isBigInt(b)) return !1;\n          if (\"object\" != typeof b) return a == b;\n          b = e.__toPrimitive(b);\n        } else if (\"object\" == typeof a) {\n          if (\"object\" == typeof b && b.constructor !== e) return a == b;\n          a = e.__toPrimitive(a);\n        } else return a == b;\n      }\n    }\n\n    static __zero() {\n      return new e(0, !1);\n    }\n\n    static __oneDigit(a, b) {\n      const c = new e(1, b);\n      return c.__setDigit(0, a), c;\n    }\n\n    __copy() {\n      const a = new e(this.length, this.sign);\n\n      for (let b = 0; b < this.length; b++) a[b] = this[b];\n\n      return a;\n    }\n\n    __trim() {\n      let a = this.length,\n          b = this[a - 1];\n\n      for (; 0 === b;) a--, b = this[a - 1], this.pop();\n\n      return 0 === a && (this.sign = !1), this;\n    }\n\n    __initializeDigits() {\n      for (let a = 0; a < this.length; a++) this[a] = 0;\n    }\n\n    static __decideRounding(a, b, c, d) {\n      if (0 < b) return -1;\n      let e;\n      if (0 > b) e = -b - 1;else {\n        if (0 === c) return -1;\n        c--, d = a.__digit(c), e = 31;\n      }\n      let f = 1 << e;\n      if (0 == (d & f)) return -1;\n      if (f -= 1, 0 != (d & f)) return 1;\n\n      for (; 0 < c;) if (c--, 0 !== a.__digit(c)) return 1;\n\n      return 0;\n    }\n\n    static __fromDouble(a) {\n      e.__kBitConversionDouble[0] = a;\n      const b = 2047 & e.__kBitConversionInts[1] >>> 20,\n            c = b - 1023,\n            d = (c >>> 5) + 1,\n            f = new e(d, 0 > a);\n      let g = 1048575 & e.__kBitConversionInts[1] | 1048576,\n          h = e.__kBitConversionInts[0];\n      const i = 20,\n            j = 31 & c;\n      let k,\n          l = 0;\n\n      if (20 > j) {\n        const a = i - j;\n        l = a + 32, k = g >>> a, g = g << 32 - a | h >>> a, h <<= 32 - a;\n      } else if (20 === j) l = 32, k = g, g = h;else {\n        const a = j - i;\n        l = 32 - a, k = g << a | h >>> 32 - a, g = h << a;\n      }\n\n      f.__setDigit(d - 1, k);\n\n      for (let b = d - 2; 0 <= b; b--) 0 < l ? (l -= 32, k = g, g = h) : k = 0, f.__setDigit(b, k);\n\n      return f.__trim();\n    }\n\n    static __isWhitespace(a) {\n      return !!(13 >= a && 9 <= a) || (159 >= a ? 32 == a : 131071 >= a ? 160 == a || 5760 == a : 196607 >= a ? (a &= 131071, 10 >= a || 40 == a || 41 == a || 47 == a || 95 == a || 4096 == a) : 65279 == a);\n    }\n\n    static __fromString(a, b = 0) {\n      let c = 0;\n      const f = a.length;\n      let g = 0;\n      if (g === f) return e.__zero();\n      let h = a.charCodeAt(g);\n\n      for (; e.__isWhitespace(h);) {\n        if (++g === f) return e.__zero();\n        h = a.charCodeAt(g);\n      }\n\n      if (43 === h) {\n        if (++g === f) return null;\n        h = a.charCodeAt(g), c = 1;\n      } else if (45 === h) {\n        if (++g === f) return null;\n        h = a.charCodeAt(g), c = -1;\n      }\n\n      if (0 === b) {\n        if (b = 10, 48 === h) {\n          if (++g === f) return e.__zero();\n\n          if (h = a.charCodeAt(g), 88 === h || 120 === h) {\n            if (b = 16, ++g === f) return null;\n            h = a.charCodeAt(g);\n          } else if (79 === h || 111 === h) {\n            if (b = 8, ++g === f) return null;\n            h = a.charCodeAt(g);\n          } else if (66 === h || 98 === h) {\n            if (b = 2, ++g === f) return null;\n            h = a.charCodeAt(g);\n          }\n        }\n      } else if (16 === b && 48 === h) {\n        if (++g === f) return e.__zero();\n\n        if (h = a.charCodeAt(g), 88 === h || 120 === h) {\n          if (++g === f) return null;\n          h = a.charCodeAt(g);\n        }\n      }\n\n      for (; 48 === h;) {\n        if (++g === f) return e.__zero();\n        h = a.charCodeAt(g);\n      }\n\n      const i = f - g;\n      let j = e.__kMaxBitsPerChar[b],\n          k = e.__kBitsPerCharTableMultiplier - 1;\n      if (i > 1073741824 / j) return null;\n      const l = j * i + k >>> e.__kBitsPerCharTableShift,\n            m = new e(l + 31 >>> 5, !1),\n            n = 10 > b ? b : 10,\n            o = 10 < b ? b - 10 : 0;\n\n      if (0 == (b & b - 1)) {\n        j >>= e.__kBitsPerCharTableShift;\n        const b = [],\n              c = [];\n        let d = !1;\n\n        do {\n          let e = 0,\n              i = 0;\n\n          for (;;) {\n            let b;\n            if (h - 48 >>> 0 < n) b = h - 48;else if ((32 | h) - 97 >>> 0 < o) b = (32 | h) - 87;else {\n              d = !0;\n              break;\n            }\n\n            if (i += j, e = e << j | b, ++g === f) {\n              d = !0;\n              break;\n            }\n\n            if (h = a.charCodeAt(g), 32 < i + j) break;\n          }\n\n          b.push(e), c.push(i);\n        } while (!d);\n\n        e.__fillFromParts(m, b, c);\n      } else {\n        m.__initializeDigits();\n\n        let c = !1,\n            i = 0;\n\n        do {\n          let l = 0,\n              p = 1;\n\n          for (;;) {\n            let e;\n            if (h - 48 >>> 0 < n) e = h - 48;else if ((32 | h) - 97 >>> 0 < o) e = (32 | h) - 87;else {\n              c = !0;\n              break;\n            }\n            const d = p * b;\n            if (4294967295 < d) break;\n\n            if (p = d, l = l * b + e, i++, ++g === f) {\n              c = !0;\n              break;\n            }\n\n            h = a.charCodeAt(g);\n          }\n\n          k = 32 * e.__kBitsPerCharTableMultiplier - 1;\n          const q = j * i + k >>> e.__kBitsPerCharTableShift + 5;\n\n          m.__inplaceMultiplyAdd(p, l, q);\n        } while (!c);\n      }\n\n      for (; g !== f;) {\n        if (!e.__isWhitespace(h)) return null;\n        h = a.charCodeAt(g++);\n      }\n\n      return 0 != c && 10 !== b ? null : (m.sign = -1 == c, m.__trim());\n    }\n\n    static __fillFromParts(a, b, c) {\n      let d = 0,\n          e = 0,\n          f = 0;\n\n      for (let g = b.length - 1; 0 <= g; g--) {\n        const h = b[g],\n              i = c[g];\n        e |= h << f, f += i, 32 === f ? (a.__setDigit(d++, e), f = 0, e = 0) : 32 < f && (a.__setDigit(d++, e), f -= 32, e = h >>> i - f);\n      }\n\n      if (0 !== e) {\n        if (d >= a.length) throw new Error(\"implementation bug\");\n\n        a.__setDigit(d++, e);\n      }\n\n      for (; d < a.length; d++) a.__setDigit(d, 0);\n    }\n\n    static __toStringBasePowerOfTwo(a, b) {\n      const c = a.length;\n      let f = b - 1;\n      f = (85 & f >>> 1) + (85 & f), f = (51 & f >>> 2) + (51 & f), f = (15 & f >>> 4) + (15 & f);\n\n      const g = f,\n            h = b - 1,\n            i = a.__digit(c - 1),\n            j = d(i);\n\n      let k = 0 | (32 * c - j + g - 1) / g;\n      if (a.sign && k++, 268435456 < k) throw new Error(\"string too long\");\n      const l = Array(k);\n      let m = k - 1,\n          n = 0,\n          o = 0;\n\n      for (let d = 0; d < c - 1; d++) {\n        const b = a.__digit(d),\n              c = (n | b << o) & h;\n\n        l[m--] = e.__kConversionChars[c];\n        const f = g - o;\n\n        for (n = b >>> f, o = 32 - f; o >= g;) l[m--] = e.__kConversionChars[n & h], n >>>= g, o -= g;\n      }\n\n      const p = (n | i << o) & h;\n\n      for (l[m--] = e.__kConversionChars[p], n = i >>> g - o; 0 !== n;) l[m--] = e.__kConversionChars[n & h], n >>>= g;\n\n      if (a.sign && (l[m--] = \"-\"), -1 != m) throw new Error(\"implementation bug\");\n      return l.join(\"\");\n    }\n\n    static __toStringGeneric(a, b, c) {\n      const f = a.length;\n      if (0 === f) return \"\";\n\n      if (1 === f) {\n        let d = a.__unsignedDigit(0).toString(b);\n\n        return !1 === c && a.sign && (d = \"-\" + d), d;\n      }\n\n      const g = 32 * f - d(a.__digit(f - 1)),\n            h = e.__kMaxBitsPerChar[b],\n            i = h - 1;\n      let j = g * e.__kBitsPerCharTableMultiplier;\n      j += i - 1, j = 0 | j / i;\n      const k = j + 1 >> 1,\n            l = e.exponentiate(e.__oneDigit(b, !1), e.__oneDigit(k, !1));\n      let m, n;\n\n      const o = l.__unsignedDigit(0);\n\n      if (1 === l.length && 65535 >= o) {\n        m = new e(a.length, !1), m.__initializeDigits();\n        let c = 0;\n\n        for (let b = 2 * a.length - 1; 0 <= b; b--) {\n          const d = c << 16 | a.__halfDigit(b);\n\n          m.__setHalfDigit(b, 0 | d / o), c = 0 | d % o;\n        }\n\n        n = c.toString(b);\n      } else {\n        const c = e.__absoluteDivLarge(a, l, !0, !0);\n\n        m = c.quotient;\n\n        const d = c.remainder.__trim();\n\n        n = e.__toStringGeneric(d, b, !0);\n      }\n\n      m.__trim();\n\n      let p = e.__toStringGeneric(m, b, !0);\n\n      for (; n.length < k;) n = \"0\" + n;\n\n      return !1 === c && a.sign && (p = \"-\" + p), p + n;\n    }\n\n    static __unequalSign(a) {\n      return a ? -1 : 1;\n    }\n\n    static __absoluteGreater(a) {\n      return a ? -1 : 1;\n    }\n\n    static __absoluteLess(a) {\n      return a ? 1 : -1;\n    }\n\n    static __compareToBigInt(a, b) {\n      const c = a.sign;\n      if (c !== b.sign) return e.__unequalSign(c);\n\n      const d = e.__absoluteCompare(a, b);\n\n      return 0 < d ? e.__absoluteGreater(c) : 0 > d ? e.__absoluteLess(c) : 0;\n    }\n\n    static __compareToNumber(a, c) {\n      if (!0 | c) {\n        const d = a.sign,\n              f = 0 > c;\n        if (d !== f) return e.__unequalSign(d);\n\n        if (0 === a.length) {\n          if (f) throw new Error(\"implementation bug\");\n          return 0 === c ? 0 : -1;\n        }\n\n        if (1 < a.length) return e.__absoluteGreater(d);\n\n        const g = b(c),\n              h = a.__unsignedDigit(0);\n\n        return h > g ? e.__absoluteGreater(d) : h < g ? e.__absoluteLess(d) : 0;\n      }\n\n      return e.__compareToDouble(a, c);\n    }\n\n    static __compareToDouble(a, b) {\n      if (b !== b) return b;\n      if (b === 1 / 0) return -1;\n      if (b === -Infinity) return 1;\n      const c = a.sign;\n      if (c !== 0 > b) return e.__unequalSign(c);\n      if (0 === b) throw new Error(\"implementation bug: should be handled elsewhere\");\n      if (0 === a.length) return -1;\n      e.__kBitConversionDouble[0] = b;\n      const f = 2047 & e.__kBitConversionInts[1] >>> 20;\n      if (2047 == f) throw new Error(\"implementation bug: handled elsewhere\");\n      const g = f - 1023;\n      if (0 > g) return e.__absoluteGreater(c);\n      const h = a.length;\n\n      let i = a.__digit(h - 1);\n\n      const j = d(i),\n            k = 32 * h - j,\n            l = g + 1;\n      if (k < l) return e.__absoluteLess(c);\n      if (k > l) return e.__absoluteGreater(c);\n      let m = 1048576 | 1048575 & e.__kBitConversionInts[1],\n          n = e.__kBitConversionInts[0];\n      const o = 20,\n            p = 31 - j;\n      if (p !== (k - 1) % 31) throw new Error(\"implementation bug\");\n      let q,\n          r = 0;\n\n      if (20 > p) {\n        const a = o - p;\n        r = a + 32, q = m >>> a, m = m << 32 - a | n >>> a, n <<= 32 - a;\n      } else if (20 === p) r = 32, q = m, m = n;else {\n        const a = p - o;\n        r = 32 - a, q = m << a | n >>> 32 - a, m = n << a;\n      }\n\n      if (i >>>= 0, q >>>= 0, i > q) return e.__absoluteGreater(c);\n      if (i < q) return e.__absoluteLess(c);\n\n      for (let d = h - 2; 0 <= d; d--) {\n        0 < r ? (r -= 32, q = m >>> 0, m = n, n = 0) : q = 0;\n\n        const b = a.__unsignedDigit(d);\n\n        if (b > q) return e.__absoluteGreater(c);\n        if (b < q) return e.__absoluteLess(c);\n      }\n\n      if (0 !== m || 0 !== n) {\n        if (0 === r) throw new Error(\"implementation bug\");\n        return e.__absoluteLess(c);\n      }\n\n      return 0;\n    }\n\n    static __equalToNumber(a, c) {\n      return c | 0 === c ? 0 === c ? 0 === a.length : 1 === a.length && a.sign === 0 > c && a.__unsignedDigit(0) === b(c) : 0 === e.__compareToDouble(a, c);\n    }\n\n    static __comparisonResultToBool(a, b) {\n      switch (b) {\n        case 0:\n          return 0 > a;\n\n        case 1:\n          return 0 >= a;\n\n        case 2:\n          return 0 < a;\n\n        case 3:\n          return 0 <= a;\n      }\n\n      throw new Error(\"unreachable\");\n    }\n\n    static __compare(a, b, c) {\n      if (a = e.__toPrimitive(a), b = e.__toPrimitive(b), \"string\" == typeof a && \"string\" == typeof b) switch (c) {\n        case 0:\n          return a < b;\n\n        case 1:\n          return a <= b;\n\n        case 2:\n          return a > b;\n\n        case 3:\n          return a >= b;\n      }\n      if (e.__isBigInt(a) && \"string\" == typeof b) return b = e.__fromString(b), null !== b && e.__comparisonResultToBool(e.__compareToBigInt(a, b), c);\n      if (\"string\" == typeof a && e.__isBigInt(b)) return a = e.__fromString(a), null !== a && e.__comparisonResultToBool(e.__compareToBigInt(a, b), c);\n\n      if (a = e.__toNumeric(a), b = e.__toNumeric(b), e.__isBigInt(a)) {\n        if (e.__isBigInt(b)) return e.__comparisonResultToBool(e.__compareToBigInt(a, b), c);\n        if (\"number\" != typeof b) throw new Error(\"implementation bug\");\n        return e.__comparisonResultToBool(e.__compareToNumber(a, b), c);\n      }\n\n      if (\"number\" != typeof a) throw new Error(\"implementation bug\");\n      if (e.__isBigInt(b)) return e.__comparisonResultToBool(e.__compareToNumber(b, a), 2 ^ c);\n      if (\"number\" != typeof b) throw new Error(\"implementation bug\");\n      return 0 === c ? a < b : 1 === c ? a <= b : 2 === c ? a > b : 3 === c ? a >= b : void 0;\n    }\n\n    __clzmsd() {\n      return d(this[this.length - 1]);\n    }\n\n    static __absoluteAdd(a, b, c) {\n      if (a.length < b.length) return e.__absoluteAdd(b, a, c);\n      if (0 === a.length) return a;\n      if (0 === b.length) return a.sign === c ? a : e.unaryMinus(a);\n      let d = a.length;\n      (0 === a.__clzmsd() || b.length === a.length && 0 === b.__clzmsd()) && d++;\n      const f = new e(d, c);\n      let g = 0,\n          h = 0;\n\n      for (; h < b.length; h++) {\n        const c = b.__digit(h),\n              d = a.__digit(h),\n              e = (65535 & d) + (65535 & c) + g,\n              i = (d >>> 16) + (c >>> 16) + (e >>> 16);\n\n        g = i >>> 16, f.__setDigit(h, 65535 & e | i << 16);\n      }\n\n      for (; h < a.length; h++) {\n        const b = a.__digit(h),\n              c = (65535 & b) + g,\n              d = (b >>> 16) + (c >>> 16);\n\n        g = d >>> 16, f.__setDigit(h, 65535 & c | d << 16);\n      }\n\n      return h < f.length && f.__setDigit(h, g), f.__trim();\n    }\n\n    static __absoluteSub(a, b, c) {\n      if (0 === a.length) return a;\n      if (0 === b.length) return a.sign === c ? a : e.unaryMinus(a);\n      const d = new e(a.length, c);\n      let f = 0,\n          g = 0;\n\n      for (; g < b.length; g++) {\n        const c = a.__digit(g),\n              e = b.__digit(g),\n              h = (65535 & c) - (65535 & e) - f;\n\n        f = 1 & h >>> 16;\n        const i = (c >>> 16) - (e >>> 16) - f;\n        f = 1 & i >>> 16, d.__setDigit(g, 65535 & h | i << 16);\n      }\n\n      for (; g < a.length; g++) {\n        const b = a.__digit(g),\n              c = (65535 & b) - f;\n\n        f = 1 & c >>> 16;\n        const e = (b >>> 16) - f;\n        f = 1 & e >>> 16, d.__setDigit(g, 65535 & c | e << 16);\n      }\n\n      return d.__trim();\n    }\n\n    static __absoluteAddOne(a, b, c = null) {\n      const d = a.length;\n      null === c ? c = new e(d, b) : c.sign = b;\n      let f = !0;\n\n      for (let e, g = 0; g < d; g++) {\n        e = a.__digit(g);\n        const b = -1 === e;\n        f && (e = 0 | e + 1), f = b, c.__setDigit(g, e);\n      }\n\n      return f && c.__setDigitGrow(d, 1), c;\n    }\n\n    static __absoluteSubOne(a, b) {\n      const c = a.length;\n      b = b || c;\n      const d = new e(b, !1);\n      let f = !0;\n\n      for (let e, g = 0; g < c; g++) {\n        e = a.__digit(g);\n        const b = 0 === e;\n        f && (e = 0 | e - 1), f = b, d.__setDigit(g, e);\n      }\n\n      for (let e = c; e < b; e++) d.__setDigit(e, 0);\n\n      return d;\n    }\n\n    static __absoluteAnd(a, b, c = null) {\n      let d = a.length,\n          f = b.length,\n          g = f;\n\n      if (d < f) {\n        g = d;\n        const c = a,\n              e = d;\n        a = b, d = f, b = c, f = e;\n      }\n\n      let h = g;\n      null === c ? c = new e(h, !1) : h = c.length;\n      let j = 0;\n\n      for (; j < g; j++) c.__setDigit(j, a.__digit(j) & b.__digit(j));\n\n      for (; j < h; j++) c.__setDigit(j, 0);\n\n      return c;\n    }\n\n    static __absoluteAndNot(a, b, c = null) {\n      const d = a.length,\n            f = b.length;\n      let g = f;\n      d < f && (g = d);\n      let h = d;\n      null === c ? c = new e(h, !1) : h = c.length;\n      let j = 0;\n\n      for (; j < g; j++) c.__setDigit(j, a.__digit(j) & ~b.__digit(j));\n\n      for (; j < d; j++) c.__setDigit(j, a.__digit(j));\n\n      for (; j < h; j++) c.__setDigit(j, 0);\n\n      return c;\n    }\n\n    static __absoluteOr(a, b, c = null) {\n      let d = a.length,\n          f = b.length,\n          g = f;\n\n      if (d < f) {\n        g = d;\n        const c = a,\n              e = d;\n        a = b, d = f, b = c, f = e;\n      }\n\n      let h = d;\n      null === c ? c = new e(h, !1) : h = c.length;\n      let j = 0;\n\n      for (; j < g; j++) c.__setDigit(j, a.__digit(j) | b.__digit(j));\n\n      for (; j < d; j++) c.__setDigit(j, a.__digit(j));\n\n      for (; j < h; j++) c.__setDigit(j, 0);\n\n      return c;\n    }\n\n    static __absoluteXor(a, b, c = null) {\n      let d = a.length,\n          f = b.length,\n          g = f;\n\n      if (d < f) {\n        g = d;\n        const c = a,\n              e = d;\n        a = b, d = f, b = c, f = e;\n      }\n\n      let h = d;\n      null === c ? c = new e(h, !1) : h = c.length;\n      let j = 0;\n\n      for (; j < g; j++) c.__setDigit(j, a.__digit(j) ^ b.__digit(j));\n\n      for (; j < d; j++) c.__setDigit(j, a.__digit(j));\n\n      for (; j < h; j++) c.__setDigit(j, 0);\n\n      return c;\n    }\n\n    static __absoluteCompare(a, b) {\n      const c = a.length - b.length;\n      if (0 != c) return c;\n      let d = a.length - 1;\n\n      for (; 0 <= d && a.__digit(d) === b.__digit(d);) d--;\n\n      return 0 > d ? 0 : a.__unsignedDigit(d) > b.__unsignedDigit(d) ? 1 : -1;\n    }\n\n    static __multiplyAccumulate(b, c, d, e) {\n      if (0 === c) return;\n      const f = 65535 & c,\n            g = c >>> 16;\n      let h = 0,\n          j = 0,\n          k = 0;\n\n      for (let l = 0; l < b.length; l++, e++) {\n        let c = d.__digit(e),\n            i = 65535 & c,\n            m = c >>> 16;\n\n        const n = b.__digit(l),\n              o = 65535 & n,\n              p = n >>> 16,\n              q = a(o, f),\n              r = a(o, g),\n              s = a(p, f),\n              t = a(p, g);\n\n        i += j + (65535 & q), m += k + h + (i >>> 16) + (q >>> 16) + (65535 & r) + (65535 & s), h = m >>> 16, j = (r >>> 16) + (s >>> 16) + (65535 & t) + h, h = j >>> 16, j &= 65535, k = t >>> 16, c = 65535 & i | m << 16, d.__setDigit(e, c);\n      }\n\n      for (; 0 != h || 0 !== j || 0 !== k; e++) {\n        let a = d.__digit(e);\n\n        const b = (65535 & a) + j,\n              c = (a >>> 16) + (b >>> 16) + k + h;\n        j = 0, k = 0, h = c >>> 16, a = 65535 & b | c << 16, d.__setDigit(e, a);\n      }\n    }\n\n    static __internalMultiplyAdd(b, c, d, e, f) {\n      let g = d,\n          h = 0;\n\n      for (let j = 0; j < e; j++) {\n        const d = b.__digit(j),\n              e = a(65535 & d, c),\n              i = (65535 & e) + h + g;\n\n        g = i >>> 16;\n        const k = a(d >>> 16, c),\n              l = (65535 & k) + (e >>> 16) + g;\n        g = l >>> 16, h = k >>> 16, f.__setDigit(j, l << 16 | 65535 & i);\n      }\n\n      if (f.length > e) for (f.__setDigit(e++, g + h); e < f.length;) f.__setDigit(e++, 0);else if (0 !== g + h) throw new Error(\"implementation bug\");\n    }\n\n    __inplaceMultiplyAdd(b, c, d) {\n      d > this.length && (d = this.length);\n      const e = 65535 & b,\n            f = b >>> 16;\n      let g = 0,\n          h = 65535 & c,\n          j = c >>> 16;\n\n      for (let k = 0; k < d; k++) {\n        const b = this.__digit(k),\n              c = 65535 & b,\n              d = b >>> 16,\n              i = a(c, e),\n              l = a(c, f),\n              m = a(d, e),\n              n = a(d, f),\n              o = h + (65535 & i),\n              p = j + g + (o >>> 16) + (i >>> 16) + (65535 & l) + (65535 & m);\n\n        h = (l >>> 16) + (m >>> 16) + (65535 & n) + (p >>> 16), g = h >>> 16, h &= 65535, j = n >>> 16;\n\n        this.__setDigit(k, 65535 & o | p << 16);\n      }\n\n      if (0 != g || 0 !== h || 0 !== j) throw new Error(\"implementation bug\");\n    }\n\n    static __absoluteDivSmall(a, b, c) {\n      null === c && (c = new e(a.length, !1));\n      let d = 0;\n\n      for (let e, f = 2 * a.length - 1; 0 <= f; f -= 2) {\n        e = (d << 16 | a.__halfDigit(f)) >>> 0;\n        const g = 0 | e / b;\n        d = 0 | e % b, e = (d << 16 | a.__halfDigit(f - 1)) >>> 0;\n        const h = 0 | e / b;\n        d = 0 | e % b, c.__setDigit(f >>> 1, g << 16 | h);\n      }\n\n      return c;\n    }\n\n    static __absoluteModSmall(a, b) {\n      let c = 0;\n\n      for (let d = 2 * a.length - 1; 0 <= d; d--) {\n        const e = (c << 16 | a.__halfDigit(d)) >>> 0;\n        c = 0 | e % b;\n      }\n\n      return c;\n    }\n\n    static __absoluteDivLarge(b, d, f, g) {\n      const h = d.__halfDigitLength(),\n            i = d.length,\n            c = b.__halfDigitLength() - h;\n\n      let k = null;\n      f && (k = new e(c + 2 >>> 1, !1), k.__initializeDigits());\n      const l = new e(h + 2 >>> 1, !1);\n\n      l.__initializeDigits();\n\n      const m = e.__clz16(d.__halfDigit(h - 1));\n\n      0 < m && (d = e.__specialLeftShift(d, m, 0));\n\n      const n = e.__specialLeftShift(b, m, 1),\n            o = d.__halfDigit(h - 1);\n\n      let p = 0;\n\n      for (let m, q = c; 0 <= q; q--) {\n        m = 65535;\n\n        const b = n.__halfDigit(q + h);\n\n        if (b !== o) {\n          const c = (b << 16 | n.__halfDigit(q + h - 1)) >>> 0;\n          m = 0 | c / o;\n          let e = 0 | c % o;\n\n          const f = d.__halfDigit(h - 2),\n                g = n.__halfDigit(q + h - 2);\n\n          for (; a(m, f) >>> 0 > (e << 16 | g) >>> 0 && (m--, e += o, !(65535 < e)););\n        }\n\n        e.__internalMultiplyAdd(d, m, 0, i, l);\n\n        let g = n.__inplaceSub(l, q, h + 1);\n\n        0 !== g && (g = n.__inplaceAdd(d, q, h), n.__setHalfDigit(q + h, n.__halfDigit(q + h) + g), m--), f && (1 & q ? p = m << 16 : k.__setDigit(q >>> 1, p | m));\n      }\n\n      return g ? (n.__inplaceRightShift(m), f ? {\n        quotient: k,\n        remainder: n\n      } : n) : f ? k : void 0;\n    }\n\n    static __clz16(a) {\n      return d(a) - 16;\n    }\n\n    __inplaceAdd(a, b, c) {\n      let d = 0;\n\n      for (let e = 0; e < c; e++) {\n        const c = this.__halfDigit(b + e) + a.__halfDigit(e) + d;\n        d = c >>> 16, this.__setHalfDigit(b + e, c);\n      }\n\n      return d;\n    }\n\n    __inplaceSub(a, b, c) {\n      let d = 0;\n\n      if (1 & b) {\n        b >>= 1;\n\n        let e = this.__digit(b),\n            f = 65535 & e,\n            g = 0;\n\n        for (; g < c - 1 >>> 1; g++) {\n          const c = a.__digit(g),\n                h = (e >>> 16) - (65535 & c) - d;\n\n          d = 1 & h >>> 16, this.__setDigit(b + g, h << 16 | 65535 & f), e = this.__digit(b + g + 1), f = (65535 & e) - (c >>> 16) - d, d = 1 & f >>> 16;\n        }\n\n        const h = a.__digit(g),\n              i = (e >>> 16) - (65535 & h) - d;\n\n        d = 1 & i >>> 16, this.__setDigit(b + g, i << 16 | 65535 & f);\n        if (b + g + 1 >= this.length) throw new RangeError(\"out of bounds\");\n        0 == (1 & c) && (e = this.__digit(b + g + 1), f = (65535 & e) - (h >>> 16) - d, d = 1 & f >>> 16, this.__setDigit(b + a.length, 4294901760 & e | 65535 & f));\n      } else {\n        b >>= 1;\n        let e = 0;\n\n        for (; e < a.length - 1; e++) {\n          const c = this.__digit(b + e),\n                f = a.__digit(e),\n                g = (65535 & c) - (65535 & f) - d;\n\n          d = 1 & g >>> 16;\n          const h = (c >>> 16) - (f >>> 16) - d;\n          d = 1 & h >>> 16, this.__setDigit(b + e, h << 16 | 65535 & g);\n        }\n\n        const f = this.__digit(b + e),\n              g = a.__digit(e),\n              h = (65535 & f) - (65535 & g) - d;\n\n        d = 1 & h >>> 16;\n        let i = 0;\n        0 == (1 & c) && (i = (f >>> 16) - (g >>> 16) - d, d = 1 & i >>> 16), this.__setDigit(b + e, i << 16 | 65535 & h);\n      }\n\n      return d;\n    }\n\n    __inplaceRightShift(a) {\n      if (0 === a) return;\n      let b = this.__digit(0) >>> a;\n      const c = this.length - 1;\n\n      for (let e = 0; e < c; e++) {\n        const c = this.__digit(e + 1);\n\n        this.__setDigit(e, c << 32 - a | b), b = c >>> a;\n      }\n\n      this.__setDigit(c, b);\n    }\n\n    static __specialLeftShift(a, b, c) {\n      const d = a.length,\n            f = new e(d + c, !1);\n\n      if (0 === b) {\n        for (let b = 0; b < d; b++) f.__setDigit(b, a.__digit(b));\n\n        return 0 < c && f.__setDigit(d, 0), f;\n      }\n\n      let g = 0;\n\n      for (let e = 0; e < d; e++) {\n        const c = a.__digit(e);\n\n        f.__setDigit(e, c << b | g), g = c >>> 32 - b;\n      }\n\n      return 0 < c && f.__setDigit(d, g), f;\n    }\n\n    static __leftShiftByAbsolute(a, b) {\n      const c = e.__toShiftAmount(b);\n\n      if (0 > c) throw new RangeError(\"BigInt too big\");\n      const f = c >>> 5,\n            g = 31 & c,\n            h = a.length,\n            i = 0 !== g && 0 != a.__digit(h - 1) >>> 32 - g,\n            j = h + f + (i ? 1 : 0),\n            k = new e(j, a.sign);\n\n      if (0 === g) {\n        let b = 0;\n\n        for (; b < f; b++) k.__setDigit(b, 0);\n\n        for (; b < j; b++) k.__setDigit(b, a.__digit(b - f));\n      } else {\n        let b = 0;\n\n        for (let a = 0; a < f; a++) k.__setDigit(a, 0);\n\n        for (let c = 0; c < h; c++) {\n          const e = a.__digit(c);\n\n          k.__setDigit(c + f, e << g | b), b = e >>> 32 - g;\n        }\n\n        if (i) k.__setDigit(h + f, b);else if (0 != b) throw new Error(\"implementation bug\");\n      }\n\n      return k.__trim();\n    }\n\n    static __rightShiftByAbsolute(a, b) {\n      const c = a.length,\n            d = a.sign,\n            f = e.__toShiftAmount(b);\n\n      if (0 > f) return e.__rightShiftByMaximum(d);\n      const g = f >>> 5,\n            h = 31 & f;\n      let i = c - g;\n      if (0 >= i) return e.__rightShiftByMaximum(d);\n      let j = !1;\n\n      if (d) {\n        if (0 != (a.__digit(g) & (1 << h) - 1)) j = !0;else for (let b = 0; b < g; b++) if (0 !== a.__digit(b)) {\n          j = !0;\n          break;\n        }\n      }\n\n      if (j && 0 === h) {\n        const b = a.__digit(c - 1);\n\n        0 == ~b && i++;\n      }\n\n      let k = new e(i, d);\n      if (0 === h) for (let b = g; b < c; b++) k.__setDigit(b - g, a.__digit(b));else {\n        let b = a.__digit(g) >>> h;\n        const d = c - g - 1;\n\n        for (let c = 0; c < d; c++) {\n          const e = a.__digit(c + g + 1);\n\n          k.__setDigit(c, e << 32 - h | b), b = e >>> h;\n        }\n\n        k.__setDigit(d, b);\n      }\n      return j && (k = e.__absoluteAddOne(k, !0, k)), k.__trim();\n    }\n\n    static __rightShiftByMaximum(a) {\n      return a ? e.__oneDigit(1, !0) : e.__zero();\n    }\n\n    static __toShiftAmount(a) {\n      if (1 < a.length) return -1;\n\n      const b = a.__unsignedDigit(0);\n\n      return b > e.__kMaxLengthBits ? -1 : b;\n    }\n\n    static __toPrimitive(a, b = \"default\") {\n      if (\"object\" != typeof a) return a;\n      if (a.constructor === e) return a;\n      const c = a[Symbol.toPrimitive];\n\n      if (c) {\n        const a = c(b);\n        if (\"object\" != typeof a) return a;\n        throw new TypeError(\"Cannot convert object to primitive value\");\n      }\n\n      const d = a.valueOf;\n\n      if (d) {\n        const b = d.call(a);\n        if (\"object\" != typeof b) return b;\n      }\n\n      const f = a.toString;\n\n      if (f) {\n        const b = f.call(a);\n        if (\"object\" != typeof b) return b;\n      }\n\n      throw new TypeError(\"Cannot convert object to primitive value\");\n    }\n\n    static __toNumeric(a) {\n      return e.__isBigInt(a) ? a : +a;\n    }\n\n    static __isBigInt(a) {\n      return \"object\" == typeof a && a.constructor === e;\n    }\n\n    __digit(a) {\n      return this[a];\n    }\n\n    __unsignedDigit(a) {\n      return this[a] >>> 0;\n    }\n\n    __setDigit(a, b) {\n      this[a] = 0 | b;\n    }\n\n    __setDigitGrow(a, b) {\n      this[a] = 0 | b;\n    }\n\n    __halfDigitLength() {\n      const a = this.length;\n      return 65535 >= this.__unsignedDigit(a - 1) ? 2 * a - 1 : 2 * a;\n    }\n\n    __halfDigit(a) {\n      return 65535 & this[a >>> 1] >>> ((1 & a) << 4);\n    }\n\n    __setHalfDigit(a, b) {\n      const c = a >>> 1,\n            d = this.__digit(c),\n            e = 1 & a ? 65535 & d | b << 16 : 4294901760 & d | 65535 & b;\n\n      this.__setDigit(c, e);\n    }\n\n    static __digitPow(a, b) {\n      let c = 1;\n\n      for (; 0 < b;) 1 & b && (c *= a), b >>>= 1, a *= a;\n\n      return c;\n    }\n\n  }\n\n  return e.__kMaxLength = 33554432, e.__kMaxLengthBits = e.__kMaxLength << 5, e.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], e.__kBitsPerCharTableShift = 5, e.__kBitsPerCharTableMultiplier = 1 << e.__kBitsPerCharTableShift, e.__kConversionChars = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"], e.__kBitConversionBuffer = new ArrayBuffer(8), e.__kBitConversionDouble = new Float64Array(e.__kBitConversionBuffer), e.__kBitConversionInts = new Int32Array(e.__kBitConversionBuffer), e;\n});","map":null,"metadata":{},"sourceType":"script"}