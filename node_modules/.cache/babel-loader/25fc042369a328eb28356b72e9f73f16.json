{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/austinvuong/AuthentiCar/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global['wavelet-client'] = factory());\n})(this, function () {\n  'use strict';\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var _global = createCommonjsModule(function (module) {\n    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n    var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func\n    : Function('return this')();\n    if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n  });\n\n  var _core = createCommonjsModule(function (module) {\n    var core = module.exports = {\n      version: '2.6.9'\n    };\n    if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n  });\n\n  var _core_1 = _core.version;\n\n  var _isObject = function (it) {\n    return typeof it === 'object' ? it !== null : typeof it === 'function';\n  };\n\n  var _anObject = function (it) {\n    if (!_isObject(it)) throw TypeError(it + ' is not an object!');\n    return it;\n  };\n\n  var _fails = function (exec) {\n    try {\n      return !!exec();\n    } catch (e) {\n      return true;\n    }\n  }; // Thank's IE8 for his funny defineProperty\n\n\n  var _descriptors = !_fails(function () {\n    return Object.defineProperty({}, 'a', {\n      get: function () {\n        return 7;\n      }\n    }).a != 7;\n  });\n\n  var document$1 = _global.document; // typeof document.createElement is 'object' in old IE\n\n  var is = _isObject(document$1) && _isObject(document$1.createElement);\n\n  var _domCreate = function (it) {\n    return is ? document$1.createElement(it) : {};\n  };\n\n  var _ie8DomDefine = !_descriptors && !_fails(function () {\n    return Object.defineProperty(_domCreate('div'), 'a', {\n      get: function () {\n        return 7;\n      }\n    }).a != 7;\n  }); // 7.1.1 ToPrimitive(input [, PreferredType])\n  // instead of the ES6 spec version, we didn't implement @@toPrimitive case\n  // and the second argument - flag - preferred type is a string\n\n\n  var _toPrimitive = function (it, S) {\n    if (!_isObject(it)) return it;\n    var fn, val;\n    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;\n    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;\n    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;\n    throw TypeError(\"Can't convert object to primitive value\");\n  };\n\n  var dP = Object.defineProperty;\n  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n    _anObject(O);\n\n    P = _toPrimitive(P, true);\n\n    _anObject(Attributes);\n\n    if (_ie8DomDefine) try {\n      return dP(O, P, Attributes);\n    } catch (e) {\n      /* empty */\n    }\n    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n    if ('value' in Attributes) O[P] = Attributes.value;\n    return O;\n  };\n  var _objectDp = {\n    f: f\n  };\n\n  var _propertyDesc = function (bitmap, value) {\n    return {\n      enumerable: !(bitmap & 1),\n      configurable: !(bitmap & 2),\n      writable: !(bitmap & 4),\n      value: value\n    };\n  };\n\n  var _hide = _descriptors ? function (object, key, value) {\n    return _objectDp.f(object, key, _propertyDesc(1, value));\n  } : function (object, key, value) {\n    object[key] = value;\n    return object;\n  };\n\n  var hasOwnProperty = {}.hasOwnProperty;\n\n  var _has = function (it, key) {\n    return hasOwnProperty.call(it, key);\n  };\n\n  var id = 0;\n  var px = Math.random();\n\n  var _uid = function (key) {\n    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n  };\n\n  var _library = false;\n\n  var _shared = createCommonjsModule(function (module) {\n    var SHARED = '__core-js_shared__';\n    var store = _global[SHARED] || (_global[SHARED] = {});\n    (module.exports = function (key, value) {\n      return store[key] || (store[key] = value !== undefined ? value : {});\n    })('versions', []).push({\n      version: _core.version,\n      mode: 'global',\n      copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'\n    });\n  });\n\n  var _functionToString = _shared('native-function-to-string', Function.toString);\n\n  var _redefine = createCommonjsModule(function (module) {\n    var SRC = _uid('src');\n\n    var TO_STRING = 'toString';\n\n    var TPL = ('' + _functionToString).split(TO_STRING);\n\n    _core.inspectSource = function (it) {\n      return _functionToString.call(it);\n    };\n\n    (module.exports = function (O, key, val, safe) {\n      var isFunction = typeof val == 'function';\n      if (isFunction) _has(val, 'name') || _hide(val, 'name', key);\n      if (O[key] === val) return;\n      if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n\n      if (O === _global) {\n        O[key] = val;\n      } else if (!safe) {\n        delete O[key];\n\n        _hide(O, key, val);\n      } else if (O[key]) {\n        O[key] = val;\n      } else {\n        _hide(O, key, val);\n      } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\n    })(Function.prototype, TO_STRING, function toString() {\n      return typeof this == 'function' && this[SRC] || _functionToString.call(this);\n    });\n  });\n\n  var _aFunction = function (it) {\n    if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n    return it;\n  }; // optional / simple context binding\n\n\n  var _ctx = function (fn, that, length) {\n    _aFunction(fn);\n\n    if (that === undefined) return fn;\n\n    switch (length) {\n      case 1:\n        return function (a) {\n          return fn.call(that, a);\n        };\n\n      case 2:\n        return function (a, b) {\n          return fn.call(that, a, b);\n        };\n\n      case 3:\n        return function (a, b, c) {\n          return fn.call(that, a, b, c);\n        };\n    }\n\n    return function ()\n    /* ...args */\n    {\n      return fn.apply(that, arguments);\n    };\n  };\n\n  var PROTOTYPE = 'prototype';\n\n  var $export = function (type, name, source) {\n    var IS_FORCED = type & $export.F;\n    var IS_GLOBAL = type & $export.G;\n    var IS_STATIC = type & $export.S;\n    var IS_PROTO = type & $export.P;\n    var IS_BIND = type & $export.B;\n    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];\n    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});\n    var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n    var key, own, out, exp;\n    if (IS_GLOBAL) source = name;\n\n    for (key in source) {\n      // contains in native\n      own = !IS_FORCED && target && target[key] !== undefined; // export native or passed\n\n      out = (own ? target : source)[key]; // bind timers to global for call from export context\n\n      exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out; // extend global\n\n      if (target) _redefine(target, key, out, type & $export.U); // export\n\n      if (exports[key] != out) _hide(exports, key, exp);\n      if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n    }\n  };\n\n  _global.core = _core; // type bitmap\n\n  $export.F = 1; // forced\n\n  $export.G = 2; // global\n\n  $export.S = 4; // static\n\n  $export.P = 8; // proto\n\n  $export.B = 16; // bind\n\n  $export.W = 32; // wrap\n\n  $export.U = 64; // safe\n\n  $export.R = 128; // real proto method for `library`\n\n  var _export = $export;\n  var toString = {}.toString;\n\n  var _cof = function (it) {\n    return toString.call(it).slice(8, -1);\n  }; // 7.2.2 IsArray(argument)\n\n\n  var _isArray = Array.isArray || function isArray(arg) {\n    return _cof(arg) == 'Array';\n  }; // 22.1.2.2 / 15.4.3.2 Array.isArray(arg)\n\n\n  _export(_export.S, 'Array', {\n    isArray: _isArray\n  });\n\n  var _wks = createCommonjsModule(function (module) {\n    var store = _shared('wks');\n\n    var Symbol = _global.Symbol;\n    var USE_SYMBOL = typeof Symbol == 'function';\n\n    var $exports = module.exports = function (name) {\n      return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));\n    };\n\n    $exports.store = store;\n  }); // getting tag from 19.1.3.6 Object.prototype.toString()\n\n\n  var TAG = _wks('toStringTag'); // ES3 wrong here\n\n\n  var ARG = _cof(function () {\n    return arguments;\n  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error\n\n  var tryGet = function (it, key) {\n    try {\n      return it[key];\n    } catch (e) {\n      /* empty */\n    }\n  };\n\n  var _classof = function (it) {\n    var O, T, B;\n    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case\n    : ARG ? _cof(O) // ES3 arguments fallback\n    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n  };\n\n  var _anInstance = function (it, Constructor, name, forbiddenField) {\n    if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {\n      throw TypeError(name + ': incorrect invocation!');\n    }\n\n    return it;\n  }; // call something on iterator step with safe closing on error\n\n\n  var _iterCall = function (iterator, fn, value, entries) {\n    try {\n      return entries ? fn(_anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)\n    } catch (e) {\n      var ret = iterator['return'];\n      if (ret !== undefined) _anObject(ret.call(iterator));\n      throw e;\n    }\n  };\n\n  var _iterators = {}; // check on default Array iterator\n\n  var ITERATOR = _wks('iterator');\n\n  var ArrayProto = Array.prototype;\n\n  var _isArrayIter = function (it) {\n    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR] === it);\n  }; // 7.1.4 ToInteger\n\n\n  var ceil = Math.ceil;\n  var floor = Math.floor;\n\n  var _toInteger = function (it) {\n    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n  }; // 7.1.15 ToLength\n\n\n  var min = Math.min;\n\n  var _toLength = function (it) {\n    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n  };\n\n  var ITERATOR$1 = _wks('iterator');\n\n  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {\n    if (it != undefined) return it[ITERATOR$1] || it['@@iterator'] || _iterators[_classof(it)];\n  };\n\n  var _forOf = createCommonjsModule(function (module) {\n    var BREAK = {};\n    var RETURN = {};\n\n    var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n      var iterFn = ITERATOR ? function () {\n        return iterable;\n      } : core_getIteratorMethod(iterable);\n\n      var f = _ctx(fn, that, entries ? 2 : 1);\n\n      var index = 0;\n      var length, step, iterator, result;\n      if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator\n\n      if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {\n        result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n        if (result === BREAK || result === RETURN) return result;\n      } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n        result = _iterCall(iterator, f, step.value, entries);\n        if (result === BREAK || result === RETURN) return result;\n      }\n    };\n\n    exports.BREAK = BREAK;\n    exports.RETURN = RETURN;\n  }); // 7.3.20 SpeciesConstructor(O, defaultConstructor)\n\n\n  var SPECIES = _wks('species');\n\n  var _speciesConstructor = function (O, D) {\n    var C = _anObject(O).constructor;\n\n    var S;\n    return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);\n  }; // fast apply, http://jsperf.lnkit.com/fast-apply/5\n\n\n  var _invoke = function (fn, args, that) {\n    var un = that === undefined;\n\n    switch (args.length) {\n      case 0:\n        return un ? fn() : fn.call(that);\n\n      case 1:\n        return un ? fn(args[0]) : fn.call(that, args[0]);\n\n      case 2:\n        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);\n\n      case 3:\n        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);\n\n      case 4:\n        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);\n    }\n\n    return fn.apply(that, args);\n  };\n\n  var document$2 = _global.document;\n\n  var _html = document$2 && document$2.documentElement;\n\n  var process = _global.process;\n  var setTask = _global.setImmediate;\n  var clearTask = _global.clearImmediate;\n  var MessageChannel = _global.MessageChannel;\n  var Dispatch = _global.Dispatch;\n  var counter = 0;\n  var queue = {};\n  var ONREADYSTATECHANGE = 'onreadystatechange';\n  var defer, channel, port;\n\n  var run = function () {\n    var id = +this; // eslint-disable-next-line no-prototype-builtins\n\n    if (queue.hasOwnProperty(id)) {\n      var fn = queue[id];\n      delete queue[id];\n      fn();\n    }\n  };\n\n  var listener = function (event) {\n    run.call(event.data);\n  }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:\n\n\n  if (!setTask || !clearTask) {\n    setTask = function setImmediate(fn) {\n      var args = [];\n      var i = 1;\n\n      while (arguments.length > i) args.push(arguments[i++]);\n\n      queue[++counter] = function () {\n        // eslint-disable-next-line no-new-func\n        _invoke(typeof fn == 'function' ? fn : Function(fn), args);\n      };\n\n      defer(counter);\n      return counter;\n    };\n\n    clearTask = function clearImmediate(id) {\n      delete queue[id];\n    }; // Node.js 0.8-\n\n\n    if (_cof(process) == 'process') {\n      defer = function (id) {\n        process.nextTick(_ctx(run, id, 1));\n      }; // Sphere (JS game engine) Dispatch API\n\n    } else if (Dispatch && Dispatch.now) {\n      defer = function (id) {\n        Dispatch.now(_ctx(run, id, 1));\n      }; // Browsers with MessageChannel, includes WebWorkers\n\n    } else if (MessageChannel) {\n      channel = new MessageChannel();\n      port = channel.port2;\n      channel.port1.onmessage = listener;\n      defer = _ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers\n      // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n    } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {\n      defer = function (id) {\n        _global.postMessage(id + '', '*');\n      };\n\n      _global.addEventListener('message', listener, false); // IE8-\n\n    } else if (ONREADYSTATECHANGE in _domCreate('script')) {\n      defer = function (id) {\n        _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {\n          _html.removeChild(this);\n\n          run.call(id);\n        };\n      }; // Rest old browsers\n\n    } else {\n      defer = function (id) {\n        setTimeout(_ctx(run, id, 1), 0);\n      };\n    }\n  }\n\n  var _task = {\n    set: setTask,\n    clear: clearTask\n  };\n  var macrotask = _task.set;\n  var Observer = _global.MutationObserver || _global.WebKitMutationObserver;\n  var process$1 = _global.process;\n  var Promise$1 = _global.Promise;\n  var isNode = _cof(process$1) == 'process';\n\n  var _microtask = function () {\n    var head, last, notify;\n\n    var flush = function () {\n      var parent, fn;\n      if (isNode && (parent = process$1.domain)) parent.exit();\n\n      while (head) {\n        fn = head.fn;\n        head = head.next;\n\n        try {\n          fn();\n        } catch (e) {\n          if (head) notify();else last = undefined;\n          throw e;\n        }\n      }\n\n      last = undefined;\n      if (parent) parent.enter();\n    }; // Node.js\n\n\n    if (isNode) {\n      notify = function () {\n        process$1.nextTick(flush);\n      }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n\n    } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {\n      var toggle = true;\n      var node = document.createTextNode('');\n      new Observer(flush).observe(node, {\n        characterData: true\n      }); // eslint-disable-line no-new\n\n      notify = function () {\n        node.data = toggle = !toggle;\n      }; // environments with maybe non-completely correct, but existent Promise\n\n    } else if (Promise$1 && Promise$1.resolve) {\n      // Promise.resolve without an argument throws an error in LG WebOS 2\n      var promise = Promise$1.resolve(undefined);\n\n      notify = function () {\n        promise.then(flush);\n      }; // for other environments - macrotask based on:\n      // - setImmediate\n      // - MessageChannel\n      // - window.postMessag\n      // - onreadystatechange\n      // - setTimeout\n\n    } else {\n      notify = function () {\n        // strange IE + webpack dev server bug - use .call(global)\n        macrotask.call(_global, flush);\n      };\n    }\n\n    return function (fn) {\n      var task = {\n        fn: fn,\n        next: undefined\n      };\n      if (last) last.next = task;\n\n      if (!head) {\n        head = task;\n        notify();\n      }\n\n      last = task;\n    };\n  }; // 25.4.1.5 NewPromiseCapability(C)\n\n\n  function PromiseCapability(C) {\n    var resolve, reject;\n    this.promise = new C(function ($$resolve, $$reject) {\n      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n      resolve = $$resolve;\n      reject = $$reject;\n    });\n    this.resolve = _aFunction(resolve);\n    this.reject = _aFunction(reject);\n  }\n\n  var f$1 = function (C) {\n    return new PromiseCapability(C);\n  };\n\n  var _newPromiseCapability = {\n    f: f$1\n  };\n\n  var _perform = function (exec) {\n    try {\n      return {\n        e: false,\n        v: exec()\n      };\n    } catch (e) {\n      return {\n        e: true,\n        v: e\n      };\n    }\n  };\n\n  var navigator = _global.navigator;\n\n  var _userAgent = navigator && navigator.userAgent || '';\n\n  var _promiseResolve = function (C, x) {\n    _anObject(C);\n\n    if (_isObject(x) && x.constructor === C) return x;\n\n    var promiseCapability = _newPromiseCapability.f(C);\n\n    var resolve = promiseCapability.resolve;\n    resolve(x);\n    return promiseCapability.promise;\n  };\n\n  var _redefineAll = function (target, src, safe) {\n    for (var key in src) _redefine(target, key, src[key], safe);\n\n    return target;\n  };\n\n  var def = _objectDp.f;\n\n  var TAG$1 = _wks('toStringTag');\n\n  var _setToStringTag = function (it, tag, stat) {\n    if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, {\n      configurable: true,\n      value: tag\n    });\n  };\n\n  var SPECIES$1 = _wks('species');\n\n  var _setSpecies = function (KEY) {\n    var C = _global[KEY];\n    if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {\n      configurable: true,\n      get: function () {\n        return this;\n      }\n    });\n  };\n\n  var ITERATOR$2 = _wks('iterator');\n\n  var SAFE_CLOSING = false;\n\n  try {\n    var riter = [7][ITERATOR$2]();\n\n    riter['return'] = function () {\n      SAFE_CLOSING = true;\n    }; // eslint-disable-next-line no-throw-literal\n\n\n    Array.from(riter, function () {\n      throw 2;\n    });\n  } catch (e) {\n    /* empty */\n  }\n\n  var _iterDetect = function (exec, skipClosing) {\n    if (!skipClosing && !SAFE_CLOSING) return false;\n    var safe = false;\n\n    try {\n      var arr = [7];\n      var iter = arr[ITERATOR$2]();\n\n      iter.next = function () {\n        return {\n          done: safe = true\n        };\n      };\n\n      arr[ITERATOR$2] = function () {\n        return iter;\n      };\n\n      exec(arr);\n    } catch (e) {\n      /* empty */\n    }\n\n    return safe;\n  };\n\n  var task = _task.set;\n\n  var microtask = _microtask();\n\n  var PROMISE = 'Promise';\n  var TypeError$1 = _global.TypeError;\n  var process$2 = _global.process;\n  var versions = process$2 && process$2.versions;\n  var v8 = versions && versions.v8 || '';\n  var $Promise = _global[PROMISE];\n  var isNode$1 = _classof(process$2) == 'process';\n\n  var empty = function () {\n    /* empty */\n  };\n\n  var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\n  var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;\n  var USE_NATIVE = !!function () {\n    try {\n      // correct subclassing with @@species support\n      var promise = $Promise.resolve(1);\n\n      var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {\n        exec(empty, empty);\n      }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n\n\n      return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n      // we can't detect it synchronously, so just check versions\n      && v8.indexOf('6.6') !== 0 && _userAgent.indexOf('Chrome/66') === -1;\n    } catch (e) {\n      /* empty */\n    }\n  }(); // helpers\n\n  var isThenable = function (it) {\n    var then;\n    return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n  };\n\n  var notify = function (promise, isReject) {\n    if (promise._n) return;\n    promise._n = true;\n    var chain = promise._c;\n    microtask(function () {\n      var value = promise._v;\n      var ok = promise._s == 1;\n      var i = 0;\n\n      var run = function (reaction) {\n        var handler = ok ? reaction.ok : reaction.fail;\n        var resolve = reaction.resolve;\n        var reject = reaction.reject;\n        var domain = reaction.domain;\n        var result, then, exited;\n\n        try {\n          if (handler) {\n            if (!ok) {\n              if (promise._h == 2) onHandleUnhandled(promise);\n              promise._h = 1;\n            }\n\n            if (handler === true) result = value;else {\n              if (domain) domain.enter();\n              result = handler(value); // may throw\n\n              if (domain) {\n                domain.exit();\n                exited = true;\n              }\n            }\n\n            if (result === reaction.promise) {\n              reject(TypeError$1('Promise-chain cycle'));\n            } else if (then = isThenable(result)) {\n              then.call(result, resolve, reject);\n            } else resolve(result);\n          } else reject(value);\n        } catch (e) {\n          if (domain && !exited) domain.exit();\n          reject(e);\n        }\n      };\n\n      while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n\n\n      promise._c = [];\n      promise._n = false;\n      if (isReject && !promise._h) onUnhandled(promise);\n    });\n  };\n\n  var onUnhandled = function (promise) {\n    task.call(_global, function () {\n      var value = promise._v;\n      var unhandled = isUnhandled(promise);\n      var result, handler, console;\n\n      if (unhandled) {\n        result = _perform(function () {\n          if (isNode$1) {\n            process$2.emit('unhandledRejection', value, promise);\n          } else if (handler = _global.onunhandledrejection) {\n            handler({\n              promise: promise,\n              reason: value\n            });\n          } else if ((console = _global.console) && console.error) {\n            console.error('Unhandled promise rejection', value);\n          }\n        }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n\n        promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;\n      }\n\n      promise._a = undefined;\n      if (unhandled && result.e) throw result.v;\n    });\n  };\n\n  var isUnhandled = function (promise) {\n    return promise._h !== 1 && (promise._a || promise._c).length === 0;\n  };\n\n  var onHandleUnhandled = function (promise) {\n    task.call(_global, function () {\n      var handler;\n\n      if (isNode$1) {\n        process$2.emit('rejectionHandled', promise);\n      } else if (handler = _global.onrejectionhandled) {\n        handler({\n          promise: promise,\n          reason: promise._v\n        });\n      }\n    });\n  };\n\n  var $reject = function (value) {\n    var promise = this;\n    if (promise._d) return;\n    promise._d = true;\n    promise = promise._w || promise; // unwrap\n\n    promise._v = value;\n    promise._s = 2;\n    if (!promise._a) promise._a = promise._c.slice();\n    notify(promise, true);\n  };\n\n  var $resolve = function (value) {\n    var promise = this;\n    var then;\n    if (promise._d) return;\n    promise._d = true;\n    promise = promise._w || promise; // unwrap\n\n    try {\n      if (promise === value) throw TypeError$1(\"Promise can't be resolved itself\");\n\n      if (then = isThenable(value)) {\n        microtask(function () {\n          var wrapper = {\n            _w: promise,\n            _d: false\n          }; // wrap\n\n          try {\n            then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));\n          } catch (e) {\n            $reject.call(wrapper, e);\n          }\n        });\n      } else {\n        promise._v = value;\n        promise._s = 1;\n        notify(promise, false);\n      }\n    } catch (e) {\n      $reject.call({\n        _w: promise,\n        _d: false\n      }, e); // wrap\n    }\n  }; // constructor polyfill\n\n\n  if (!USE_NATIVE) {\n    // 25.4.3.1 Promise(executor)\n    $Promise = function Promise(executor) {\n      _anInstance(this, $Promise, PROMISE, '_h');\n\n      _aFunction(executor);\n\n      Internal.call(this);\n\n      try {\n        executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));\n      } catch (err) {\n        $reject.call(this, err);\n      }\n    }; // eslint-disable-next-line no-unused-vars\n\n\n    Internal = function Promise(executor) {\n      this._c = []; // <- awaiting reactions\n\n      this._a = undefined; // <- checked in isUnhandled reactions\n\n      this._s = 0; // <- state\n\n      this._d = false; // <- done\n\n      this._v = undefined; // <- value\n\n      this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n\n      this._n = false; // <- notify\n    };\n\n    Internal.prototype = _redefineAll($Promise.prototype, {\n      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n      then: function then(onFulfilled, onRejected) {\n        var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));\n        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n        reaction.fail = typeof onRejected == 'function' && onRejected;\n        reaction.domain = isNode$1 ? process$2.domain : undefined;\n\n        this._c.push(reaction);\n\n        if (this._a) this._a.push(reaction);\n        if (this._s) notify(this, false);\n        return reaction.promise;\n      },\n      // 25.4.5.1 Promise.prototype.catch(onRejected)\n      'catch': function (onRejected) {\n        return this.then(undefined, onRejected);\n      }\n    });\n\n    OwnPromiseCapability = function () {\n      var promise = new Internal();\n      this.promise = promise;\n      this.resolve = _ctx($resolve, promise, 1);\n      this.reject = _ctx($reject, promise, 1);\n    };\n\n    _newPromiseCapability.f = newPromiseCapability = function (C) {\n      return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);\n    };\n  }\n\n  _export(_export.G + _export.W + _export.F * !USE_NATIVE, {\n    Promise: $Promise\n  });\n\n  _setToStringTag($Promise, PROMISE);\n\n  _setSpecies(PROMISE);\n\n  Wrapper = _core[PROMISE]; // statics\n\n  _export(_export.S + _export.F * !USE_NATIVE, PROMISE, {\n    // 25.4.4.5 Promise.reject(r)\n    reject: function reject(r) {\n      var capability = newPromiseCapability(this);\n      var $$reject = capability.reject;\n      $$reject(r);\n      return capability.promise;\n    }\n  });\n\n  _export(_export.S + _export.F * !USE_NATIVE, PROMISE, {\n    // 25.4.4.6 Promise.resolve(x)\n    resolve: function resolve(x) {\n      return _promiseResolve(this, x);\n    }\n  });\n\n  _export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {\n    $Promise.all(iter)['catch'](empty);\n  })), PROMISE, {\n    // 25.4.4.1 Promise.all(iterable)\n    all: function all(iterable) {\n      var C = this;\n      var capability = newPromiseCapability(C);\n      var resolve = capability.resolve;\n      var reject = capability.reject;\n\n      var result = _perform(function () {\n        var values = [];\n        var index = 0;\n        var remaining = 1;\n\n        _forOf(iterable, false, function (promise) {\n          var $index = index++;\n          var alreadyCalled = false;\n          values.push(undefined);\n          remaining++;\n          C.resolve(promise).then(function (value) {\n            if (alreadyCalled) return;\n            alreadyCalled = true;\n            values[$index] = value;\n            --remaining || resolve(values);\n          }, reject);\n        });\n\n        --remaining || resolve(values);\n      });\n\n      if (result.e) reject(result.v);\n      return capability.promise;\n    },\n    // 25.4.4.4 Promise.race(iterable)\n    race: function race(iterable) {\n      var C = this;\n      var capability = newPromiseCapability(C);\n      var reject = capability.reject;\n\n      var result = _perform(function () {\n        _forOf(iterable, false, function (promise) {\n          C.resolve(promise).then(capability.resolve, reject);\n        });\n      });\n\n      if (result.e) reject(result.v);\n      return capability.promise;\n    }\n  }); // 22.1.3.31 Array.prototype[@@unscopables]\n\n\n  var UNSCOPABLES = _wks('unscopables');\n\n  var ArrayProto$1 = Array.prototype;\n  if (ArrayProto$1[UNSCOPABLES] == undefined) _hide(ArrayProto$1, UNSCOPABLES, {});\n\n  var _addToUnscopables = function (key) {\n    ArrayProto$1[UNSCOPABLES][key] = true;\n  };\n\n  var _iterStep = function (done, value) {\n    return {\n      value: value,\n      done: !!done\n    };\n  }; // fallback for non-array-like ES3 and non-enumerable old V8 strings\n  // eslint-disable-next-line no-prototype-builtins\n\n\n  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n    return _cof(it) == 'String' ? it.split('') : Object(it);\n  }; // 7.2.1 RequireObjectCoercible(argument)\n\n\n  var _defined = function (it) {\n    if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n    return it;\n  }; // to indexed object, toObject with fallback for non-array-like ES3 strings\n\n\n  var _toIobject = function (it) {\n    return _iobject(_defined(it));\n  };\n\n  var max = Math.max;\n  var min$1 = Math.min;\n\n  var _toAbsoluteIndex = function (index, length) {\n    index = _toInteger(index);\n    return index < 0 ? max(index + length, 0) : min$1(index, length);\n  }; // false -> Array#indexOf\n  // true  -> Array#includes\n\n\n  var _arrayIncludes = function (IS_INCLUDES) {\n    return function ($this, el, fromIndex) {\n      var O = _toIobject($this);\n\n      var length = _toLength(O.length);\n\n      var index = _toAbsoluteIndex(fromIndex, length);\n\n      var value; // Array#includes uses SameValueZero equality algorithm\n      // eslint-disable-next-line no-self-compare\n\n      if (IS_INCLUDES && el != el) while (length > index) {\n        value = O[index++]; // eslint-disable-next-line no-self-compare\n\n        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not\n      } else for (; length > index; index++) if (IS_INCLUDES || index in O) {\n        if (O[index] === el) return IS_INCLUDES || index || 0;\n      }\n      return !IS_INCLUDES && -1;\n    };\n  };\n\n  var shared = _shared('keys');\n\n  var _sharedKey = function (key) {\n    return shared[key] || (shared[key] = _uid(key));\n  };\n\n  var arrayIndexOf = _arrayIncludes(false);\n\n  var IE_PROTO = _sharedKey('IE_PROTO');\n\n  var _objectKeysInternal = function (object, names) {\n    var O = _toIobject(object);\n\n    var i = 0;\n    var result = [];\n    var key;\n\n    for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key); // Don't enum bug & hidden keys\n\n\n    while (names.length > i) if (_has(O, key = names[i++])) {\n      ~arrayIndexOf(result, key) || result.push(key);\n    }\n\n    return result;\n  }; // IE 8- don't enum bug keys\n\n\n  var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(','); // 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\n\n  var _objectKeys = Object.keys || function keys(O) {\n    return _objectKeysInternal(O, _enumBugKeys);\n  };\n\n  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n    _anObject(O);\n\n    var keys = _objectKeys(Properties);\n\n    var length = keys.length;\n    var i = 0;\n    var P;\n\n    while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);\n\n    return O;\n  }; // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\n\n  var IE_PROTO$1 = _sharedKey('IE_PROTO');\n\n  var Empty = function () {\n    /* empty */\n  };\n\n  var PROTOTYPE$1 = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype\n\n  var createDict = function () {\n    // Thrash, waste and sodomy: IE GC bug\n    var iframe = _domCreate('iframe');\n\n    var i = _enumBugKeys.length;\n    var lt = '<';\n    var gt = '>';\n    var iframeDocument;\n    iframe.style.display = 'none';\n\n    _html.appendChild(iframe);\n\n    iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n    // createDict = iframe.contentWindow.Object;\n    // html.removeChild(iframe);\n\n    iframeDocument = iframe.contentWindow.document;\n    iframeDocument.open();\n    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n    iframeDocument.close();\n    createDict = iframeDocument.F;\n\n    while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];\n\n    return createDict();\n  };\n\n  var _objectCreate = Object.create || function create(O, Properties) {\n    var result;\n\n    if (O !== null) {\n      Empty[PROTOTYPE$1] = _anObject(O);\n      result = new Empty();\n      Empty[PROTOTYPE$1] = null; // add \"__proto__\" for Object.getPrototypeOf polyfill\n\n      result[IE_PROTO$1] = O;\n    } else result = createDict();\n\n    return Properties === undefined ? result : _objectDps(result, Properties);\n  };\n\n  var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\n  _hide(IteratorPrototype, _wks('iterator'), function () {\n    return this;\n  });\n\n  var _iterCreate = function (Constructor, NAME, next) {\n    Constructor.prototype = _objectCreate(IteratorPrototype, {\n      next: _propertyDesc(1, next)\n    });\n\n    _setToStringTag(Constructor, NAME + ' Iterator');\n  }; // 7.1.13 ToObject(argument)\n\n\n  var _toObject = function (it) {\n    return Object(_defined(it));\n  }; // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\n\n  var IE_PROTO$2 = _sharedKey('IE_PROTO');\n\n  var ObjectProto = Object.prototype;\n\n  var _objectGpo = Object.getPrototypeOf || function (O) {\n    O = _toObject(O);\n    if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];\n\n    if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n      return O.constructor.prototype;\n    }\n\n    return O instanceof Object ? ObjectProto : null;\n  };\n\n  var ITERATOR$3 = _wks('iterator');\n\n  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\n\n  var FF_ITERATOR = '@@iterator';\n  var KEYS = 'keys';\n  var VALUES = 'values';\n\n  var returnThis = function () {\n    return this;\n  };\n\n  var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n    _iterCreate(Constructor, NAME, next);\n\n    var getMethod = function (kind) {\n      if (!BUGGY && kind in proto) return proto[kind];\n\n      switch (kind) {\n        case KEYS:\n          return function keys() {\n            return new Constructor(this, kind);\n          };\n\n        case VALUES:\n          return function values() {\n            return new Constructor(this, kind);\n          };\n      }\n\n      return function entries() {\n        return new Constructor(this, kind);\n      };\n    };\n\n    var TAG = NAME + ' Iterator';\n    var DEF_VALUES = DEFAULT == VALUES;\n    var VALUES_BUG = false;\n    var proto = Base.prototype;\n    var $native = proto[ITERATOR$3] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n    var $default = $native || getMethod(DEFAULT);\n    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n    var methods, key, IteratorPrototype; // Fix native\n\n    if ($anyNative) {\n      IteratorPrototype = _objectGpo($anyNative.call(new Base()));\n\n      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n        // Set @@toStringTag to native iterators\n        _setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines\n\n\n        if (typeof IteratorPrototype[ITERATOR$3] != 'function') _hide(IteratorPrototype, ITERATOR$3, returnThis);\n      }\n    } // fix Array#{values, @@iterator}.name in V8 / FF\n\n\n    if (DEF_VALUES && $native && $native.name !== VALUES) {\n      VALUES_BUG = true;\n\n      $default = function values() {\n        return $native.call(this);\n      };\n    } // Define iterator\n\n\n    if (BUGGY || VALUES_BUG || !proto[ITERATOR$3]) {\n      _hide(proto, ITERATOR$3, $default);\n    } // Plug for library\n\n\n    _iterators[NAME] = $default;\n    _iterators[TAG] = returnThis;\n\n    if (DEFAULT) {\n      methods = {\n        values: DEF_VALUES ? $default : getMethod(VALUES),\n        keys: IS_SET ? $default : getMethod(KEYS),\n        entries: $entries\n      };\n      if (FORCED) for (key in methods) {\n        if (!(key in proto)) _redefine(proto, key, methods[key]);\n      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);\n    }\n\n    return methods;\n  }; // 22.1.3.4 Array.prototype.entries()\n  // 22.1.3.13 Array.prototype.keys()\n  // 22.1.3.29 Array.prototype.values()\n  // 22.1.3.30 Array.prototype[@@iterator]()\n\n\n  var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {\n    this._t = _toIobject(iterated); // target\n\n    this._i = 0; // next index\n\n    this._k = kind; // kind\n    // 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n  }, function () {\n    var O = this._t;\n    var kind = this._k;\n    var index = this._i++;\n\n    if (!O || index >= O.length) {\n      this._t = undefined;\n      return _iterStep(1);\n    }\n\n    if (kind == 'keys') return _iterStep(0, index);\n    if (kind == 'values') return _iterStep(0, O[index]);\n    return _iterStep(0, [index, O[index]]);\n  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\n\n  _iterators.Arguments = _iterators.Array;\n\n  _addToUnscopables('keys');\n\n  _addToUnscopables('values');\n\n  _addToUnscopables('entries');\n\n  var ITERATOR$4 = _wks('iterator');\n\n  var TO_STRING_TAG = _wks('toStringTag');\n\n  var ArrayValues = _iterators.Array;\n  var DOMIterables = {\n    CSSRuleList: true,\n    // TODO: Not spec compliant, should be false.\n    CSSStyleDeclaration: false,\n    CSSValueList: false,\n    ClientRectList: false,\n    DOMRectList: false,\n    DOMStringList: false,\n    DOMTokenList: true,\n    DataTransferItemList: false,\n    FileList: false,\n    HTMLAllCollection: false,\n    HTMLCollection: false,\n    HTMLFormElement: false,\n    HTMLSelectElement: false,\n    MediaList: true,\n    // TODO: Not spec compliant, should be false.\n    MimeTypeArray: false,\n    NamedNodeMap: false,\n    NodeList: true,\n    PaintRequestList: false,\n    Plugin: false,\n    PluginArray: false,\n    SVGLengthList: false,\n    SVGNumberList: false,\n    SVGPathSegList: false,\n    SVGPointList: false,\n    SVGStringList: false,\n    SVGTransformList: false,\n    SourceBufferList: false,\n    StyleSheetList: true,\n    // TODO: Not spec compliant, should be false.\n    TextTrackCueList: false,\n    TextTrackList: false,\n    TouchList: false\n  };\n\n  for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {\n    var NAME = collections[i];\n    var explicit = DOMIterables[NAME];\n    var Collection = _global[NAME];\n    var proto = Collection && Collection.prototype;\n    var key;\n\n    if (proto) {\n      if (!proto[ITERATOR$4]) _hide(proto, ITERATOR$4, ArrayValues);\n      if (!proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);\n      _iterators[NAME] = ArrayValues;\n      if (explicit) for (key in es6_array_iterator) if (!proto[key]) _redefine(proto, key, es6_array_iterator[key], true);\n    }\n  } // true  -> String#at\n  // false -> String#codePointAt\n\n\n  var _stringAt = function (TO_STRING) {\n    return function (that, pos) {\n      var s = String(_defined(that));\n\n      var i = _toInteger(pos);\n\n      var l = s.length;\n      var a, b;\n      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n      a = s.charCodeAt(i);\n      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n    };\n  };\n\n  var $at = _stringAt(true); // 21.1.3.27 String.prototype[@@iterator]()\n\n\n  _iterDefine(String, 'String', function (iterated) {\n    this._t = String(iterated); // target\n\n    this._i = 0; // next index\n    // 21.1.5.2.1 %StringIteratorPrototype%.next()\n  }, function () {\n    var O = this._t;\n    var index = this._i;\n    var point;\n    if (index >= O.length) return {\n      value: undefined,\n      done: true\n    };\n    point = $at(O, index);\n    this._i += point.length;\n    return {\n      value: point,\n      done: false\n    };\n  });\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function () {\n      var self = this,\n          args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      if (i % 2) {\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n            return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n          }));\n        }\n\n        ownKeys.forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i]));\n      }\n    }\n\n    return target;\n  }\n\n  var at = _stringAt(true); // `AdvanceStringIndex` abstract operation\n  // https://tc39.github.io/ecma262/#sec-advancestringindex\n\n\n  var _advanceStringIndex = function (S, index, unicode) {\n    return index + (unicode ? at(S, index).length : 1);\n  };\n\n  var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation\n  // https://tc39.github.io/ecma262/#sec-regexpexec\n\n  var _regexpExecAbstract = function (R, S) {\n    var exec = R.exec;\n\n    if (typeof exec === 'function') {\n      var result = exec.call(R, S);\n\n      if (typeof result !== 'object') {\n        throw new TypeError('RegExp exec method returned something other than an Object or null');\n      }\n\n      return result;\n    }\n\n    if (_classof(R) !== 'RegExp') {\n      throw new TypeError('RegExp#exec called on incompatible receiver');\n    }\n\n    return builtinExec.call(R, S);\n  }; // 21.2.5.3 get RegExp.prototype.flags\n\n\n  var _flags = function () {\n    var that = _anObject(this);\n\n    var result = '';\n    if (that.global) result += 'g';\n    if (that.ignoreCase) result += 'i';\n    if (that.multiline) result += 'm';\n    if (that.unicode) result += 'u';\n    if (that.sticky) result += 'y';\n    return result;\n  };\n\n  var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the\n  // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\n  // which loads this file before patching the method.\n\n  var nativeReplace = String.prototype.replace;\n  var patchedExec = nativeExec;\n  var LAST_INDEX = 'lastIndex';\n\n  var UPDATES_LAST_INDEX_WRONG = function () {\n    var re1 = /a/,\n        re2 = /b*/g;\n    nativeExec.call(re1, 'a');\n    nativeExec.call(re2, 'a');\n    return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;\n  }(); // nonparticipating capturing group, copied from es5-shim's String#split patch.\n\n\n  var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;\n\n  if (PATCH) {\n    patchedExec = function exec(str) {\n      var re = this;\n      var lastIndex, reCopy, match, i;\n\n      if (NPCG_INCLUDED) {\n        reCopy = new RegExp('^' + re.source + '$(?!\\\\s)', _flags.call(re));\n      }\n\n      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];\n      match = nativeExec.call(re, str);\n\n      if (UPDATES_LAST_INDEX_WRONG && match) {\n        re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;\n      }\n\n      if (NPCG_INCLUDED && match && match.length > 1) {\n        // Fix browsers whose `exec` methods don't consistently return `undefined`\n        // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n        // eslint-disable-next-line no-loop-func\n        nativeReplace.call(match[0], reCopy, function () {\n          for (i = 1; i < arguments.length - 2; i++) {\n            if (arguments[i] === undefined) match[i] = undefined;\n          }\n        });\n      }\n\n      return match;\n    };\n  }\n\n  var _regexpExec = patchedExec;\n\n  _export({\n    target: 'RegExp',\n    proto: true,\n    forced: _regexpExec !== /./.exec\n  }, {\n    exec: _regexpExec\n  });\n\n  var SPECIES$2 = _wks('species');\n\n  var REPLACE_SUPPORTS_NAMED_GROUPS = !_fails(function () {\n    // #replace needs built-in support for named groups.\n    // #match works fine because it just return the exec results, even if it has\n    // a \"grops\" property.\n    var re = /./;\n\n    re.exec = function () {\n      var result = [];\n      result.groups = {\n        a: '7'\n      };\n      return result;\n    };\n\n    return ''.replace(re, '$<a>') !== '7';\n  });\n\n  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {\n    // Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n    var re = /(?:)/;\n    var originalExec = re.exec;\n\n    re.exec = function () {\n      return originalExec.apply(this, arguments);\n    };\n\n    var result = 'ab'.split(re);\n    return result.length === 2 && result[0] === 'a' && result[1] === 'b';\n  }();\n\n  var _fixReWks = function (KEY, length, exec) {\n    var SYMBOL = _wks(KEY);\n\n    var DELEGATES_TO_SYMBOL = !_fails(function () {\n      // String methods call symbol-named RegEp methods\n      var O = {};\n\n      O[SYMBOL] = function () {\n        return 7;\n      };\n\n      return ''[KEY](O) != 7;\n    });\n    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !_fails(function () {\n      // Symbol-named RegExp methods call .exec\n      var execCalled = false;\n      var re = /a/;\n\n      re.exec = function () {\n        execCalled = true;\n        return null;\n      };\n\n      if (KEY === 'split') {\n        // RegExp[@@split] doesn't call the regex's exec method, but first creates\n        // a new one. We need to return the patched regex when creating the new one.\n        re.constructor = {};\n\n        re.constructor[SPECIES$2] = function () {\n          return re;\n        };\n      }\n\n      re[SYMBOL]('');\n      return !execCalled;\n    }) : undefined;\n\n    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {\n      var nativeRegExpMethod = /./[SYMBOL];\n      var fns = exec(_defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {\n        if (regexp.exec === _regexpExec) {\n          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n            // The native String method already delegates to @@method (this\n            // polyfilled function), leasing to infinite recursion.\n            // We avoid it by directly calling the native @@method method.\n            return {\n              done: true,\n              value: nativeRegExpMethod.call(regexp, str, arg2)\n            };\n          }\n\n          return {\n            done: true,\n            value: nativeMethod.call(str, regexp, arg2)\n          };\n        }\n\n        return {\n          done: false\n        };\n      });\n      var strfn = fns[0];\n      var rxfn = fns[1];\n\n      _redefine(String.prototype, KEY, strfn);\n\n      _hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) {\n        return rxfn.call(string, this, arg);\n      } // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) {\n        return rxfn.call(string, this);\n      });\n    }\n  }; // @@match logic\n\n\n  _fixReWks('match', 1, function (defined, MATCH, $match, maybeCallNative) {\n    return [// `String.prototype.match` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.match\n    function match(regexp) {\n      var O = defined(this);\n      var fn = regexp == undefined ? undefined : regexp[MATCH];\n      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n    }, // `RegExp.prototype[@@match]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match\n    function (regexp) {\n      var res = maybeCallNative($match, regexp, this);\n      if (res.done) return res.value;\n\n      var rx = _anObject(regexp);\n\n      var S = String(this);\n      if (!rx.global) return _regexpExecAbstract(rx, S);\n      var fullUnicode = rx.unicode;\n      rx.lastIndex = 0;\n      var A = [];\n      var n = 0;\n      var result;\n\n      while ((result = _regexpExecAbstract(rx, S)) !== null) {\n        var matchStr = String(result[0]);\n        A[n] = matchStr;\n        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);\n        n++;\n      }\n\n      return n === 0 ? null : A;\n    }];\n  });\n\n  var SPECIES$3 = _wks('species');\n\n  var _arraySpeciesConstructor = function (original) {\n    var C;\n\n    if (_isArray(original)) {\n      C = original.constructor; // cross-realm fallback\n\n      if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;\n\n      if (_isObject(C)) {\n        C = C[SPECIES$3];\n        if (C === null) C = undefined;\n      }\n    }\n\n    return C === undefined ? Array : C;\n  }; // 9.4.2.3 ArraySpeciesCreate(originalArray, length)\n\n\n  var _arraySpeciesCreate = function (original, length) {\n    return new (_arraySpeciesConstructor(original))(length);\n  }; // 0 -> Array#forEach\n  // 1 -> Array#map\n  // 2 -> Array#filter\n  // 3 -> Array#some\n  // 4 -> Array#every\n  // 5 -> Array#find\n  // 6 -> Array#findIndex\n\n\n  var _arrayMethods = function (TYPE, $create) {\n    var IS_MAP = TYPE == 1;\n    var IS_FILTER = TYPE == 2;\n    var IS_SOME = TYPE == 3;\n    var IS_EVERY = TYPE == 4;\n    var IS_FIND_INDEX = TYPE == 6;\n    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n    var create = $create || _arraySpeciesCreate;\n    return function ($this, callbackfn, that) {\n      var O = _toObject($this);\n\n      var self = _iobject(O);\n\n      var f = _ctx(callbackfn, that, 3);\n\n      var length = _toLength(self.length);\n\n      var index = 0;\n      var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n      var val, res;\n\n      for (; length > index; index++) if (NO_HOLES || index in self) {\n        val = self[index];\n        res = f(val, index, O);\n\n        if (TYPE) {\n          if (IS_MAP) result[index] = res; // map\n          else if (res) switch (TYPE) {\n              case 3:\n                return true;\n              // some\n\n              case 5:\n                return val;\n              // find\n\n              case 6:\n                return index;\n              // findIndex\n\n              case 2:\n                result.push(val);\n              // filter\n            } else if (IS_EVERY) return false; // every\n        }\n      }\n\n      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n    };\n  };\n\n  var _strictMethod = function (method, arg) {\n    return !!method && _fails(function () {\n      // eslint-disable-next-line no-useless-call\n      arg ? method.call(null, function () {\n        /* empty */\n      }, 1) : method.call(null);\n    });\n  };\n\n  var $map = _arrayMethods(1);\n\n  _export(_export.P + _export.F * !_strictMethod([].map, true), 'Array', {\n    // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])\n    map: function map(callbackfn\n    /* , thisArg */\n    ) {\n      return $map(this, callbackfn, arguments[1]);\n    }\n  });\n\n  var $forEach = _arrayMethods(0);\n\n  var STRICT = _strictMethod([].forEach, true);\n\n  _export(_export.P + _export.F * !STRICT, 'Array', {\n    // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])\n    forEach: function forEach(callbackfn\n    /* , thisArg */\n    ) {\n      return $forEach(this, callbackfn, arguments[1]);\n    }\n  });\n\n  var runtime = createCommonjsModule(function (module) {\n    /**\n     * Copyright (c) 2014, Facebook, Inc.\n     * All rights reserved.\n     *\n     * This source code is licensed under the BSD-style license found in the\n     * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n     * additional grant of patent rights can be found in the PATENTS file in\n     * the same directory.\n     */\n    !function (global) {\n      var Op = Object.prototype;\n      var hasOwn = Op.hasOwnProperty;\n      var undefined$1; // More compressible than void 0.\n\n      var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n      var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n      var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n      var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n      var runtime = global.regeneratorRuntime;\n\n      if (runtime) {\n        {\n          // If regeneratorRuntime is defined globally and we're in a module,\n          // make the exports object identical to regeneratorRuntime.\n          module.exports = runtime;\n        } // Don't bother evaluating the rest of this file if the runtime was\n        // already defined globally.\n\n        return;\n      } // Define the runtime globally (as expected by generated code) as either\n      // module.exports (if we're in a module) or a new, empty object.\n\n\n      runtime = global.regeneratorRuntime = module.exports;\n\n      function wrap(innerFn, outerFn, self, tryLocsList) {\n        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n        var generator = Object.create(protoGenerator.prototype);\n        var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n        // .throw, and .return methods.\n\n        generator._invoke = makeInvokeMethod(innerFn, self, context);\n        return generator;\n      }\n\n      runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n      // record like context.tryEntries[i].completion. This interface could\n      // have been (and was previously) designed to take a closure to be\n      // invoked without arguments, but in all the cases we care about we\n      // already have an existing method we want to call, so there's no need\n      // to create a new function object. We can even get away with assuming\n      // the method takes exactly one argument, since that happens to be true\n      // in every case, so we don't have to touch the arguments object. The\n      // only additional allocation required is the completion record, which\n      // has a stable shape and so hopefully should be cheap to allocate.\n\n      function tryCatch(fn, obj, arg) {\n        try {\n          return {\n            type: \"normal\",\n            arg: fn.call(obj, arg)\n          };\n        } catch (err) {\n          return {\n            type: \"throw\",\n            arg: err\n          };\n        }\n      }\n\n      var GenStateSuspendedStart = \"suspendedStart\";\n      var GenStateSuspendedYield = \"suspendedYield\";\n      var GenStateExecuting = \"executing\";\n      var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n      // breaking out of the dispatch switch statement.\n\n      var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n      // .constructor.prototype properties for functions that return Generator\n      // objects. For full spec compliance, you may wish to configure your\n      // minifier not to mangle the names of these two functions.\n\n      function Generator() {}\n\n      function GeneratorFunction() {}\n\n      function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n      // don't natively support it.\n\n\n      var IteratorPrototype = {};\n\n      IteratorPrototype[iteratorSymbol] = function () {\n        return this;\n      };\n\n      var getProto = Object.getPrototypeOf;\n      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n        // This environment has a native %IteratorPrototype%; use it instead\n        // of the polyfill.\n        IteratorPrototype = NativeIteratorPrototype;\n      }\n\n      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n      GeneratorFunctionPrototype.constructor = GeneratorFunction;\n      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n      // Iterator interface in terms of a single ._invoke method.\n\n      function defineIteratorMethods(prototype) {\n        [\"next\", \"throw\", \"return\"].forEach(function (method) {\n          prototype[method] = function (arg) {\n            return this._invoke(method, arg);\n          };\n        });\n      }\n\n      runtime.isGeneratorFunction = function (genFun) {\n        var ctor = typeof genFun === \"function\" && genFun.constructor;\n        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n      };\n\n      runtime.mark = function (genFun) {\n        if (Object.setPrototypeOf) {\n          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n        } else {\n          genFun.__proto__ = GeneratorFunctionPrototype;\n\n          if (!(toStringTagSymbol in genFun)) {\n            genFun[toStringTagSymbol] = \"GeneratorFunction\";\n          }\n        }\n\n        genFun.prototype = Object.create(Gp);\n        return genFun;\n      }; // Within the body of any async function, `await x` is transformed to\n      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n      // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n      // meant to be awaited.\n\n\n      runtime.awrap = function (arg) {\n        return {\n          __await: arg\n        };\n      };\n\n      function AsyncIterator(generator) {\n        function invoke(method, arg, resolve, reject) {\n          var record = tryCatch(generator[method], generator, arg);\n\n          if (record.type === \"throw\") {\n            reject(record.arg);\n          } else {\n            var result = record.arg;\n            var value = result.value;\n\n            if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n              return Promise.resolve(value.__await).then(function (value) {\n                invoke(\"next\", value, resolve, reject);\n              }, function (err) {\n                invoke(\"throw\", err, resolve, reject);\n              });\n            }\n\n            return Promise.resolve(value).then(function (unwrapped) {\n              // When a yielded Promise is resolved, its final value becomes\n              // the .value of the Promise<{value,done}> result for the\n              // current iteration. If the Promise is rejected, however, the\n              // result for this iteration will be rejected with the same\n              // reason. Note that rejections of yielded Promises are not\n              // thrown back into the generator function, as is the case\n              // when an awaited Promise is rejected. This difference in\n              // behavior between yield and await is important, because it\n              // allows the consumer to decide what to do with the yielded\n              // rejection (swallow it and continue, manually .throw it back\n              // into the generator, abandon iteration, whatever). With\n              // await, by contrast, there is no opportunity to examine the\n              // rejection reason outside the generator function, so the\n              // only option is to throw it from the await expression, and\n              // let the generator function handle the exception.\n              result.value = unwrapped;\n              resolve(result);\n            }, reject);\n          }\n        }\n\n        var previousPromise;\n\n        function enqueue(method, arg) {\n          function callInvokeWithMethodAndArg() {\n            return new Promise(function (resolve, reject) {\n              invoke(method, arg, resolve, reject);\n            });\n          }\n\n          return previousPromise = // If enqueue has been called before, then we want to wait until\n          // all previous Promises have been resolved before calling invoke,\n          // so that results are always delivered in the correct order. If\n          // enqueue has not been called before, then it is important to\n          // call invoke immediately, without waiting on a callback to fire,\n          // so that the async generator function has the opportunity to do\n          // any necessary setup in a predictable way. This predictability\n          // is why the Promise constructor synchronously invokes its\n          // executor callback, and why async functions synchronously\n          // execute code before the first await. Since we implement simple\n          // async functions in terms of async generators, it is especially\n          // important to get this right, even though it requires care.\n          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n        } // Define the unified helper method that is used to implement .next,\n        // .throw, and .return (see defineIteratorMethods).\n\n\n        this._invoke = enqueue;\n      }\n\n      defineIteratorMethods(AsyncIterator.prototype);\n\n      AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n        return this;\n      };\n\n      runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n      // AsyncIterator objects; they just return a Promise for the value of\n      // the final result produced by the iterator.\n\n      runtime.async = function (innerFn, outerFn, self, tryLocsList) {\n        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n        return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n        : iter.next().then(function (result) {\n          return result.done ? result.value : iter.next();\n        });\n      };\n\n      function makeInvokeMethod(innerFn, self, context) {\n        var state = GenStateSuspendedStart;\n        return function invoke(method, arg) {\n          if (state === GenStateExecuting) {\n            throw new Error(\"Generator is already running\");\n          }\n\n          if (state === GenStateCompleted) {\n            if (method === \"throw\") {\n              throw arg;\n            } // Be forgiving, per 25.3.3.3.3 of the spec:\n            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n            return doneResult();\n          }\n\n          context.method = method;\n          context.arg = arg;\n\n          while (true) {\n            var delegate = context.delegate;\n\n            if (delegate) {\n              var delegateResult = maybeInvokeDelegate(delegate, context);\n\n              if (delegateResult) {\n                if (delegateResult === ContinueSentinel) continue;\n                return delegateResult;\n              }\n            }\n\n            if (context.method === \"next\") {\n              // Setting context._sent for legacy support of Babel's\n              // function.sent implementation.\n              context.sent = context._sent = context.arg;\n            } else if (context.method === \"throw\") {\n              if (state === GenStateSuspendedStart) {\n                state = GenStateCompleted;\n                throw context.arg;\n              }\n\n              context.dispatchException(context.arg);\n            } else if (context.method === \"return\") {\n              context.abrupt(\"return\", context.arg);\n            }\n\n            state = GenStateExecuting;\n            var record = tryCatch(innerFn, self, context);\n\n            if (record.type === \"normal\") {\n              // If an exception is thrown from innerFn, we leave state ===\n              // GenStateExecuting and loop back for another invocation.\n              state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n              if (record.arg === ContinueSentinel) {\n                continue;\n              }\n\n              return {\n                value: record.arg,\n                done: context.done\n              };\n            } else if (record.type === \"throw\") {\n              state = GenStateCompleted; // Dispatch the exception by looping back around to the\n              // context.dispatchException(context.arg) call above.\n\n              context.method = \"throw\";\n              context.arg = record.arg;\n            }\n          }\n        };\n      } // Call delegate.iterator[context.method](context.arg) and handle the\n      // result, either by returning a { value, done } result from the\n      // delegate iterator, or by modifying context.method and context.arg,\n      // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n      function maybeInvokeDelegate(delegate, context) {\n        var method = delegate.iterator[context.method];\n\n        if (method === undefined$1) {\n          // A .throw or .return when the delegate iterator has no .throw\n          // method always terminates the yield* loop.\n          context.delegate = null;\n\n          if (context.method === \"throw\") {\n            if (delegate.iterator.return) {\n              // If the delegate iterator has a return method, give it a\n              // chance to clean up.\n              context.method = \"return\";\n              context.arg = undefined$1;\n              maybeInvokeDelegate(delegate, context);\n\n              if (context.method === \"throw\") {\n                // If maybeInvokeDelegate(context) changed context.method from\n                // \"return\" to \"throw\", let that override the TypeError below.\n                return ContinueSentinel;\n              }\n            }\n\n            context.method = \"throw\";\n            context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n          }\n\n          return ContinueSentinel;\n        }\n\n        var record = tryCatch(method, delegate.iterator, context.arg);\n\n        if (record.type === \"throw\") {\n          context.method = \"throw\";\n          context.arg = record.arg;\n          context.delegate = null;\n          return ContinueSentinel;\n        }\n\n        var info = record.arg;\n\n        if (!info) {\n          context.method = \"throw\";\n          context.arg = new TypeError(\"iterator result is not an object\");\n          context.delegate = null;\n          return ContinueSentinel;\n        }\n\n        if (info.done) {\n          // Assign the result of the finished delegate to the temporary\n          // variable specified by delegate.resultName (see delegateYield).\n          context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n          context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n          // exception, let the outer generator proceed normally. If\n          // context.method was \"next\", forget context.arg since it has been\n          // \"consumed\" by the delegate iterator. If context.method was\n          // \"return\", allow the original .return call to continue in the\n          // outer generator.\n\n          if (context.method !== \"return\") {\n            context.method = \"next\";\n            context.arg = undefined$1;\n          }\n        } else {\n          // Re-yield the result returned by the delegate method.\n          return info;\n        } // The delegate iterator is finished, so forget it and continue with\n        // the outer generator.\n\n\n        context.delegate = null;\n        return ContinueSentinel;\n      } // Define Generator.prototype.{next,throw,return} in terms of the\n      // unified ._invoke helper method.\n\n\n      defineIteratorMethods(Gp);\n      Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\n      // @@iterator function is called on it. Some browsers' implementations of the\n      // iterator prototype chain incorrectly implement this, causing the Generator\n      // object to not be returned from this call. This ensures that doesn't happen.\n      // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n      Gp[iteratorSymbol] = function () {\n        return this;\n      };\n\n      Gp.toString = function () {\n        return \"[object Generator]\";\n      };\n\n      function pushTryEntry(locs) {\n        var entry = {\n          tryLoc: locs[0]\n        };\n\n        if (1 in locs) {\n          entry.catchLoc = locs[1];\n        }\n\n        if (2 in locs) {\n          entry.finallyLoc = locs[2];\n          entry.afterLoc = locs[3];\n        }\n\n        this.tryEntries.push(entry);\n      }\n\n      function resetTryEntry(entry) {\n        var record = entry.completion || {};\n        record.type = \"normal\";\n        delete record.arg;\n        entry.completion = record;\n      }\n\n      function Context(tryLocsList) {\n        // The root entry object (effectively a try statement without a catch\n        // or a finally block) gives us a place to store values thrown from\n        // locations where there is no enclosing try statement.\n        this.tryEntries = [{\n          tryLoc: \"root\"\n        }];\n        tryLocsList.forEach(pushTryEntry, this);\n        this.reset(true);\n      }\n\n      runtime.keys = function (object) {\n        var keys = [];\n\n        for (var key in object) {\n          keys.push(key);\n        }\n\n        keys.reverse(); // Rather than returning an object with a next method, we keep\n        // things simple and return the next function itself.\n\n        return function next() {\n          while (keys.length) {\n            var key = keys.pop();\n\n            if (key in object) {\n              next.value = key;\n              next.done = false;\n              return next;\n            }\n          } // To avoid creating an additional object, we just hang the .value\n          // and .done properties off the next function object itself. This\n          // also ensures that the minifier will not anonymize the function.\n\n\n          next.done = true;\n          return next;\n        };\n      };\n\n      function values(iterable) {\n        if (iterable) {\n          var iteratorMethod = iterable[iteratorSymbol];\n\n          if (iteratorMethod) {\n            return iteratorMethod.call(iterable);\n          }\n\n          if (typeof iterable.next === \"function\") {\n            return iterable;\n          }\n\n          if (!isNaN(iterable.length)) {\n            var i = -1,\n                next = function next() {\n              while (++i < iterable.length) {\n                if (hasOwn.call(iterable, i)) {\n                  next.value = iterable[i];\n                  next.done = false;\n                  return next;\n                }\n              }\n\n              next.value = undefined$1;\n              next.done = true;\n              return next;\n            };\n\n            return next.next = next;\n          }\n        } // Return an iterator with no values.\n\n\n        return {\n          next: doneResult\n        };\n      }\n\n      runtime.values = values;\n\n      function doneResult() {\n        return {\n          value: undefined$1,\n          done: true\n        };\n      }\n\n      Context.prototype = {\n        constructor: Context,\n        reset: function (skipTempReset) {\n          this.prev = 0;\n          this.next = 0; // Resetting context._sent for legacy support of Babel's\n          // function.sent implementation.\n\n          this.sent = this._sent = undefined$1;\n          this.done = false;\n          this.delegate = null;\n          this.method = \"next\";\n          this.arg = undefined$1;\n          this.tryEntries.forEach(resetTryEntry);\n\n          if (!skipTempReset) {\n            for (var name in this) {\n              // Not sure about the optimal order of these conditions:\n              if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n                this[name] = undefined$1;\n              }\n            }\n          }\n        },\n        stop: function () {\n          this.done = true;\n          var rootEntry = this.tryEntries[0];\n          var rootRecord = rootEntry.completion;\n\n          if (rootRecord.type === \"throw\") {\n            throw rootRecord.arg;\n          }\n\n          return this.rval;\n        },\n        dispatchException: function (exception) {\n          if (this.done) {\n            throw exception;\n          }\n\n          var context = this;\n\n          function handle(loc, caught) {\n            record.type = \"throw\";\n            record.arg = exception;\n            context.next = loc;\n\n            if (caught) {\n              // If the dispatched exception was caught by a catch block,\n              // then let that catch block handle the exception normally.\n              context.method = \"next\";\n              context.arg = undefined$1;\n            }\n\n            return !!caught;\n          }\n\n          for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n            var entry = this.tryEntries[i];\n            var record = entry.completion;\n\n            if (entry.tryLoc === \"root\") {\n              // Exception thrown outside of any try block that could handle\n              // it, so set the completion value of the entire function to\n              // throw the exception.\n              return handle(\"end\");\n            }\n\n            if (entry.tryLoc <= this.prev) {\n              var hasCatch = hasOwn.call(entry, \"catchLoc\");\n              var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n              if (hasCatch && hasFinally) {\n                if (this.prev < entry.catchLoc) {\n                  return handle(entry.catchLoc, true);\n                } else if (this.prev < entry.finallyLoc) {\n                  return handle(entry.finallyLoc);\n                }\n              } else if (hasCatch) {\n                if (this.prev < entry.catchLoc) {\n                  return handle(entry.catchLoc, true);\n                }\n              } else if (hasFinally) {\n                if (this.prev < entry.finallyLoc) {\n                  return handle(entry.finallyLoc);\n                }\n              } else {\n                throw new Error(\"try statement without catch or finally\");\n              }\n            }\n          }\n        },\n        abrupt: function (type, arg) {\n          for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n            var entry = this.tryEntries[i];\n\n            if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n              var finallyEntry = entry;\n              break;\n            }\n          }\n\n          if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n            // Ignore the finally entry if control is not jumping to a\n            // location outside the try/catch block.\n            finallyEntry = null;\n          }\n\n          var record = finallyEntry ? finallyEntry.completion : {};\n          record.type = type;\n          record.arg = arg;\n\n          if (finallyEntry) {\n            this.method = \"next\";\n            this.next = finallyEntry.finallyLoc;\n            return ContinueSentinel;\n          }\n\n          return this.complete(record);\n        },\n        complete: function (record, afterLoc) {\n          if (record.type === \"throw\") {\n            throw record.arg;\n          }\n\n          if (record.type === \"break\" || record.type === \"continue\") {\n            this.next = record.arg;\n          } else if (record.type === \"return\") {\n            this.rval = this.arg = record.arg;\n            this.method = \"return\";\n            this.next = \"end\";\n          } else if (record.type === \"normal\" && afterLoc) {\n            this.next = afterLoc;\n          }\n\n          return ContinueSentinel;\n        },\n        finish: function (finallyLoc) {\n          for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n            var entry = this.tryEntries[i];\n\n            if (entry.finallyLoc === finallyLoc) {\n              this.complete(entry.completion, entry.afterLoc);\n              resetTryEntry(entry);\n              return ContinueSentinel;\n            }\n          }\n        },\n        \"catch\": function (tryLoc) {\n          for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n            var entry = this.tryEntries[i];\n\n            if (entry.tryLoc === tryLoc) {\n              var record = entry.completion;\n\n              if (record.type === \"throw\") {\n                var thrown = record.arg;\n                resetTryEntry(entry);\n              }\n\n              return thrown;\n            }\n          } // The context.catch method must only be called with a location\n          // argument that corresponds to a known catch block.\n\n\n          throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function (iterable, resultName, nextLoc) {\n          this.delegate = {\n            iterator: values(iterable),\n            resultName: resultName,\n            nextLoc: nextLoc\n          };\n\n          if (this.method === \"next\") {\n            // Deliberately forget the last sent value so that we don't\n            // accidentally pass it on to the delegate.\n            this.arg = undefined$1;\n          }\n\n          return ContinueSentinel;\n        }\n      };\n    }( // In sloppy mode, unbound `this` refers to the global object, fallback to\n    // Function constructor if we're in global strict mode. That is sadly a form\n    // of indirect eval which violates Content Security Policy.\n    function () {\n      return this;\n    }() || Function(\"return this\")());\n  }); // 21.2.5.3 get RegExp.prototype.flags()\n\n  if (_descriptors && /./g.flags != 'g') _objectDp.f(RegExp.prototype, 'flags', {\n    configurable: true,\n    get: _flags\n  });\n  var TO_STRING = 'toString';\n  var $toString = /./[TO_STRING];\n\n  var define = function (fn) {\n    _redefine(RegExp.prototype, TO_STRING, fn, true);\n  }; // 21.2.5.14 RegExp.prototype.toString()\n\n\n  if (_fails(function () {\n    return $toString.call({\n      source: 'a',\n      flags: 'b'\n    }) != '/a/b';\n  })) {\n    define(function toString() {\n      var R = _anObject(this);\n\n      return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);\n    }); // FF44- RegExp#toString has a wrong name\n  } else if ($toString.name != TO_STRING) {\n    define(function toString() {\n      return $toString.call(this);\n    });\n  }\n\n  var DateProto = Date.prototype;\n  var INVALID_DATE = 'Invalid Date';\n  var TO_STRING$1 = 'toString';\n  var $toString$1 = DateProto[TO_STRING$1];\n  var getTime = DateProto.getTime;\n\n  if (new Date(NaN) + '' != INVALID_DATE) {\n    _redefine(DateProto, TO_STRING$1, function toString() {\n      var value = getTime.call(this); // eslint-disable-next-line no-self-compare\n\n      return value === value ? $toString$1.call(this) : INVALID_DATE;\n    });\n  } // 19.1.3.6 Object.prototype.toString()\n\n\n  var test = {};\n  test[_wks('toStringTag')] = 'z';\n\n  if (test + '' != '[object z]') {\n    _redefine(Object.prototype, 'toString', function toString() {\n      return '[object ' + _classof(this) + ']';\n    }, true);\n  }\n\n  var TYPED = _uid('typed_array');\n\n  var VIEW = _uid('view');\n\n  var ABV = !!(_global.ArrayBuffer && _global.DataView);\n  var CONSTR = ABV;\n  var i$1 = 0;\n  var l = 9;\n  var Typed;\n  var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');\n\n  while (i$1 < l) {\n    if (Typed = _global[TypedArrayConstructors[i$1++]]) {\n      _hide(Typed.prototype, TYPED, true);\n\n      _hide(Typed.prototype, VIEW, true);\n    } else CONSTR = false;\n  }\n\n  var _typed = {\n    ABV: ABV,\n    CONSTR: CONSTR,\n    TYPED: TYPED,\n    VIEW: VIEW\n  }; // https://tc39.github.io/ecma262/#sec-toindex\n\n  var _toIndex = function (it) {\n    if (it === undefined) return 0;\n\n    var number = _toInteger(it);\n\n    var length = _toLength(number);\n\n    if (number !== length) throw RangeError('Wrong length!');\n    return length;\n  }; // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n\n\n  var hiddenKeys = _enumBugKeys.concat('length', 'prototype');\n\n  var f$2 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n    return _objectKeysInternal(O, hiddenKeys);\n  };\n\n  var _objectGopn = {\n    f: f$2\n  };\n\n  var _arrayFill = function fill(value\n  /* , start = 0, end = @length */\n  ) {\n    var O = _toObject(this);\n\n    var length = _toLength(O.length);\n\n    var aLen = arguments.length;\n\n    var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);\n\n    var end = aLen > 2 ? arguments[2] : undefined;\n    var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);\n\n    while (endPos > index) O[index++] = value;\n\n    return O;\n  };\n\n  var _typedBuffer = createCommonjsModule(function (module, exports) {\n    var gOPN = _objectGopn.f;\n    var dP = _objectDp.f;\n    var ARRAY_BUFFER = 'ArrayBuffer';\n    var DATA_VIEW = 'DataView';\n    var PROTOTYPE = 'prototype';\n    var WRONG_LENGTH = 'Wrong length!';\n    var WRONG_INDEX = 'Wrong index!';\n    var $ArrayBuffer = _global[ARRAY_BUFFER];\n    var $DataView = _global[DATA_VIEW];\n    var Math = _global.Math;\n    var RangeError = _global.RangeError; // eslint-disable-next-line no-shadow-restricted-names\n\n    var Infinity = _global.Infinity;\n    var BaseBuffer = $ArrayBuffer;\n    var abs = Math.abs;\n    var pow = Math.pow;\n    var floor = Math.floor;\n    var log = Math.log;\n    var LN2 = Math.LN2;\n    var BUFFER = 'buffer';\n    var BYTE_LENGTH = 'byteLength';\n    var BYTE_OFFSET = 'byteOffset';\n    var $BUFFER = _descriptors ? '_b' : BUFFER;\n    var $LENGTH = _descriptors ? '_l' : BYTE_LENGTH;\n    var $OFFSET = _descriptors ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754\n\n    function packIEEE754(value, mLen, nBytes) {\n      var buffer = new Array(nBytes);\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;\n      var i = 0;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      var e, m, c;\n      value = abs(value); // eslint-disable-next-line no-self-compare\n\n      if (value != value || value === Infinity) {\n        // eslint-disable-next-line no-self-compare\n        m = value != value ? 1 : 0;\n        e = eMax;\n      } else {\n        e = floor(log(value) / LN2);\n\n        if (value * (c = pow(2, -e)) < 1) {\n          e--;\n          c *= 2;\n        }\n\n        if (e + eBias >= 1) {\n          value += rt / c;\n        } else {\n          value += rt * pow(2, 1 - eBias);\n        }\n\n        if (value * c >= 2) {\n          e++;\n          c /= 2;\n        }\n\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = (value * c - 1) * pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * pow(2, eBias - 1) * pow(2, mLen);\n          e = 0;\n        }\n      }\n\n      for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n\n      e = e << mLen | m;\n      eLen += mLen;\n\n      for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n\n      buffer[--i] |= s * 128;\n      return buffer;\n    }\n\n    function unpackIEEE754(buffer, mLen, nBytes) {\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = eLen - 7;\n      var i = nBytes - 1;\n      var s = buffer[i--];\n      var e = s & 127;\n      var m;\n      s >>= 7;\n\n      for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n\n      m = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n\n      for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : s ? -Infinity : Infinity;\n      } else {\n        m = m + pow(2, mLen);\n        e = e - eBias;\n      }\n\n      return (s ? -1 : 1) * m * pow(2, e - mLen);\n    }\n\n    function unpackI32(bytes) {\n      return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n    }\n\n    function packI8(it) {\n      return [it & 0xff];\n    }\n\n    function packI16(it) {\n      return [it & 0xff, it >> 8 & 0xff];\n    }\n\n    function packI32(it) {\n      return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n    }\n\n    function packF64(it) {\n      return packIEEE754(it, 52, 8);\n    }\n\n    function packF32(it) {\n      return packIEEE754(it, 23, 4);\n    }\n\n    function addGetter(C, key, internal) {\n      dP(C[PROTOTYPE], key, {\n        get: function () {\n          return this[internal];\n        }\n      });\n    }\n\n    function get(view, bytes, index, isLittleEndian) {\n      var numIndex = +index;\n\n      var intIndex = _toIndex(numIndex);\n\n      if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n      var store = view[$BUFFER]._b;\n      var start = intIndex + view[$OFFSET];\n      var pack = store.slice(start, start + bytes);\n      return isLittleEndian ? pack : pack.reverse();\n    }\n\n    function set(view, bytes, index, conversion, value, isLittleEndian) {\n      var numIndex = +index;\n\n      var intIndex = _toIndex(numIndex);\n\n      if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n      var store = view[$BUFFER]._b;\n      var start = intIndex + view[$OFFSET];\n      var pack = conversion(+value);\n\n      for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n    }\n\n    if (!_typed.ABV) {\n      $ArrayBuffer = function ArrayBuffer(length) {\n        _anInstance(this, $ArrayBuffer, ARRAY_BUFFER);\n\n        var byteLength = _toIndex(length);\n\n        this._b = _arrayFill.call(new Array(byteLength), 0);\n        this[$LENGTH] = byteLength;\n      };\n\n      $DataView = function DataView(buffer, byteOffset, byteLength) {\n        _anInstance(this, $DataView, DATA_VIEW);\n\n        _anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n\n        var bufferLength = buffer[$LENGTH];\n\n        var offset = _toInteger(byteOffset);\n\n        if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');\n        byteLength = byteLength === undefined ? bufferLength - offset : _toLength(byteLength);\n        if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);\n        this[$BUFFER] = buffer;\n        this[$OFFSET] = offset;\n        this[$LENGTH] = byteLength;\n      };\n\n      if (_descriptors) {\n        addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n        addGetter($DataView, BUFFER, '_b');\n        addGetter($DataView, BYTE_LENGTH, '_l');\n        addGetter($DataView, BYTE_OFFSET, '_o');\n      }\n\n      _redefineAll($DataView[PROTOTYPE], {\n        getInt8: function getInt8(byteOffset) {\n          return get(this, 1, byteOffset)[0] << 24 >> 24;\n        },\n        getUint8: function getUint8(byteOffset) {\n          return get(this, 1, byteOffset)[0];\n        },\n        getInt16: function getInt16(byteOffset\n        /* , littleEndian */\n        ) {\n          var bytes = get(this, 2, byteOffset, arguments[1]);\n          return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n        },\n        getUint16: function getUint16(byteOffset\n        /* , littleEndian */\n        ) {\n          var bytes = get(this, 2, byteOffset, arguments[1]);\n          return bytes[1] << 8 | bytes[0];\n        },\n        getInt32: function getInt32(byteOffset\n        /* , littleEndian */\n        ) {\n          return unpackI32(get(this, 4, byteOffset, arguments[1]));\n        },\n        getUint32: function getUint32(byteOffset\n        /* , littleEndian */\n        ) {\n          return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n        },\n        getFloat32: function getFloat32(byteOffset\n        /* , littleEndian */\n        ) {\n          return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n        },\n        getFloat64: function getFloat64(byteOffset\n        /* , littleEndian */\n        ) {\n          return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n        },\n        setInt8: function setInt8(byteOffset, value) {\n          set(this, 1, byteOffset, packI8, value);\n        },\n        setUint8: function setUint8(byteOffset, value) {\n          set(this, 1, byteOffset, packI8, value);\n        },\n        setInt16: function setInt16(byteOffset, value\n        /* , littleEndian */\n        ) {\n          set(this, 2, byteOffset, packI16, value, arguments[2]);\n        },\n        setUint16: function setUint16(byteOffset, value\n        /* , littleEndian */\n        ) {\n          set(this, 2, byteOffset, packI16, value, arguments[2]);\n        },\n        setInt32: function setInt32(byteOffset, value\n        /* , littleEndian */\n        ) {\n          set(this, 4, byteOffset, packI32, value, arguments[2]);\n        },\n        setUint32: function setUint32(byteOffset, value\n        /* , littleEndian */\n        ) {\n          set(this, 4, byteOffset, packI32, value, arguments[2]);\n        },\n        setFloat32: function setFloat32(byteOffset, value\n        /* , littleEndian */\n        ) {\n          set(this, 4, byteOffset, packF32, value, arguments[2]);\n        },\n        setFloat64: function setFloat64(byteOffset, value\n        /* , littleEndian */\n        ) {\n          set(this, 8, byteOffset, packF64, value, arguments[2]);\n        }\n      });\n    } else {\n      if (!_fails(function () {\n        $ArrayBuffer(1);\n      }) || !_fails(function () {\n        new $ArrayBuffer(-1); // eslint-disable-line no-new\n      }) || _fails(function () {\n        new $ArrayBuffer(); // eslint-disable-line no-new\n\n        new $ArrayBuffer(1.5); // eslint-disable-line no-new\n\n        new $ArrayBuffer(NaN); // eslint-disable-line no-new\n\n        return $ArrayBuffer.name != ARRAY_BUFFER;\n      })) {\n        $ArrayBuffer = function ArrayBuffer(length) {\n          _anInstance(this, $ArrayBuffer);\n\n          return new BaseBuffer(_toIndex(length));\n        };\n\n        var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n\n        for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {\n          if (!((key = keys[j++]) in $ArrayBuffer)) _hide($ArrayBuffer, key, BaseBuffer[key]);\n        }\n\n        ArrayBufferProto.constructor = $ArrayBuffer;\n      } // iOS Safari 7.x bug\n\n\n      var view = new $DataView(new $ArrayBuffer(2));\n      var $setInt8 = $DataView[PROTOTYPE].setInt8;\n      view.setInt8(0, 2147483648);\n      view.setInt8(1, 2147483649);\n      if (view.getInt8(0) || !view.getInt8(1)) _redefineAll($DataView[PROTOTYPE], {\n        setInt8: function setInt8(byteOffset, value) {\n          $setInt8.call(this, byteOffset, value << 24 >> 24);\n        },\n        setUint8: function setUint8(byteOffset, value) {\n          $setInt8.call(this, byteOffset, value << 24 >> 24);\n        }\n      }, true);\n    }\n\n    _setToStringTag($ArrayBuffer, ARRAY_BUFFER);\n\n    _setToStringTag($DataView, DATA_VIEW);\n\n    _hide($DataView[PROTOTYPE], _typed.VIEW, true);\n\n    exports[ARRAY_BUFFER] = $ArrayBuffer;\n    exports[DATA_VIEW] = $DataView;\n  });\n\n  _export(_export.G + _export.W + _export.F * !_typed.ABV, {\n    DataView: _typedBuffer.DataView\n  });\n\n  var _arrayCopyWithin = [].copyWithin || function copyWithin(target\n  /* = 0 */\n  , start\n  /* = 0, end = @length */\n  ) {\n    var O = _toObject(this);\n\n    var len = _toLength(O.length);\n\n    var to = _toAbsoluteIndex(target, len);\n\n    var from = _toAbsoluteIndex(start, len);\n\n    var end = arguments.length > 2 ? arguments[2] : undefined;\n    var count = Math.min((end === undefined ? len : _toAbsoluteIndex(end, len)) - from, len - to);\n    var inc = 1;\n\n    if (from < to && to < from + count) {\n      inc = -1;\n      from += count - 1;\n      to += count - 1;\n    }\n\n    while (count-- > 0) {\n      if (from in O) O[to] = O[from];else delete O[to];\n      to += inc;\n      from += inc;\n    }\n\n    return O;\n  };\n\n  var f$3 = {}.propertyIsEnumerable;\n  var _objectPie = {\n    f: f$3\n  };\n  var gOPD = Object.getOwnPropertyDescriptor;\n  var f$4 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {\n    O = _toIobject(O);\n    P = _toPrimitive(P, true);\n    if (_ie8DomDefine) try {\n      return gOPD(O, P);\n    } catch (e) {\n      /* empty */\n    }\n    if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);\n  };\n  var _objectGopd = {\n    f: f$4\n  };\n\n  var _typedArray = createCommonjsModule(function (module) {\n    if (_descriptors) {\n      var LIBRARY = _library;\n      var global = _global;\n      var fails = _fails;\n      var $export = _export;\n      var $typed = _typed;\n      var $buffer = _typedBuffer;\n      var ctx = _ctx;\n      var anInstance = _anInstance;\n      var propertyDesc = _propertyDesc;\n      var hide = _hide;\n      var redefineAll = _redefineAll;\n      var toInteger = _toInteger;\n      var toLength = _toLength;\n      var toIndex = _toIndex;\n      var toAbsoluteIndex = _toAbsoluteIndex;\n      var toPrimitive = _toPrimitive;\n      var has = _has;\n      var classof = _classof;\n      var isObject = _isObject;\n      var toObject = _toObject;\n      var isArrayIter = _isArrayIter;\n      var create = _objectCreate;\n      var getPrototypeOf = _objectGpo;\n      var gOPN = _objectGopn.f;\n      var getIterFn = core_getIteratorMethod;\n      var uid = _uid;\n      var wks = _wks;\n      var createArrayMethod = _arrayMethods;\n      var createArrayIncludes = _arrayIncludes;\n      var speciesConstructor = _speciesConstructor;\n      var ArrayIterators = es6_array_iterator;\n      var Iterators = _iterators;\n      var $iterDetect = _iterDetect;\n      var setSpecies = _setSpecies;\n      var arrayFill = _arrayFill;\n      var arrayCopyWithin = _arrayCopyWithin;\n      var $DP = _objectDp;\n      var $GOPD = _objectGopd;\n      var dP = $DP.f;\n      var gOPD = $GOPD.f;\n      var RangeError = global.RangeError;\n      var TypeError = global.TypeError;\n      var Uint8Array = global.Uint8Array;\n      var ARRAY_BUFFER = 'ArrayBuffer';\n      var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;\n      var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\n      var PROTOTYPE = 'prototype';\n      var ArrayProto = Array[PROTOTYPE];\n      var $ArrayBuffer = $buffer.ArrayBuffer;\n      var $DataView = $buffer.DataView;\n      var arrayForEach = createArrayMethod(0);\n      var arrayFilter = createArrayMethod(2);\n      var arraySome = createArrayMethod(3);\n      var arrayEvery = createArrayMethod(4);\n      var arrayFind = createArrayMethod(5);\n      var arrayFindIndex = createArrayMethod(6);\n      var arrayIncludes = createArrayIncludes(true);\n      var arrayIndexOf = createArrayIncludes(false);\n      var arrayValues = ArrayIterators.values;\n      var arrayKeys = ArrayIterators.keys;\n      var arrayEntries = ArrayIterators.entries;\n      var arrayLastIndexOf = ArrayProto.lastIndexOf;\n      var arrayReduce = ArrayProto.reduce;\n      var arrayReduceRight = ArrayProto.reduceRight;\n      var arrayJoin = ArrayProto.join;\n      var arraySort = ArrayProto.sort;\n      var arraySlice = ArrayProto.slice;\n      var arrayToString = ArrayProto.toString;\n      var arrayToLocaleString = ArrayProto.toLocaleString;\n      var ITERATOR = wks('iterator');\n      var TAG = wks('toStringTag');\n      var TYPED_CONSTRUCTOR = uid('typed_constructor');\n      var DEF_CONSTRUCTOR = uid('def_constructor');\n      var ALL_CONSTRUCTORS = $typed.CONSTR;\n      var TYPED_ARRAY = $typed.TYPED;\n      var VIEW = $typed.VIEW;\n      var WRONG_LENGTH = 'Wrong length!';\n      var $map = createArrayMethod(1, function (O, length) {\n        return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n      });\n      var LITTLE_ENDIAN = fails(function () {\n        // eslint-disable-next-line no-undef\n        return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n      });\n      var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {\n        new Uint8Array(1).set({});\n      });\n\n      var toOffset = function (it, BYTES) {\n        var offset = toInteger(it);\n        if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');\n        return offset;\n      };\n\n      var validate = function (it) {\n        if (isObject(it) && TYPED_ARRAY in it) return it;\n        throw TypeError(it + ' is not a typed array!');\n      };\n\n      var allocate = function (C, length) {\n        if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {\n          throw TypeError('It is not a typed array constructor!');\n        }\n\n        return new C(length);\n      };\n\n      var speciesFromList = function (O, list) {\n        return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n      };\n\n      var fromList = function (C, list) {\n        var index = 0;\n        var length = list.length;\n        var result = allocate(C, length);\n\n        while (length > index) result[index] = list[index++];\n\n        return result;\n      };\n\n      var addGetter = function (it, key, internal) {\n        dP(it, key, {\n          get: function () {\n            return this._d[internal];\n          }\n        });\n      };\n\n      var $from = function from(source\n      /* , mapfn, thisArg */\n      ) {\n        var O = toObject(source);\n        var aLen = arguments.length;\n        var mapfn = aLen > 1 ? arguments[1] : undefined;\n        var mapping = mapfn !== undefined;\n        var iterFn = getIterFn(O);\n        var i, length, values, result, step, iterator;\n\n        if (iterFn != undefined && !isArrayIter(iterFn)) {\n          for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {\n            values.push(step.value);\n          }\n\n          O = values;\n        }\n\n        if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);\n\n        for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {\n          result[i] = mapping ? mapfn(O[i], i) : O[i];\n        }\n\n        return result;\n      };\n\n      var $of = function of()\n      /* ...items */\n      {\n        var index = 0;\n        var length = arguments.length;\n        var result = allocate(this, length);\n\n        while (length > index) result[index] = arguments[index++];\n\n        return result;\n      }; // iOS Safari 6.x fails here\n\n\n      var TO_LOCALE_BUG = !!Uint8Array && fails(function () {\n        arrayToLocaleString.call(new Uint8Array(1));\n      });\n\n      var $toLocaleString = function toLocaleString() {\n        return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n      };\n\n      var proto = {\n        copyWithin: function copyWithin(target, start\n        /* , end */\n        ) {\n          return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n        },\n        every: function every(callbackfn\n        /* , thisArg */\n        ) {\n          return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n        },\n        fill: function fill(value\n        /* , start, end */\n        ) {\n          // eslint-disable-line no-unused-vars\n          return arrayFill.apply(validate(this), arguments);\n        },\n        filter: function filter(callbackfn\n        /* , thisArg */\n        ) {\n          return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));\n        },\n        find: function find(predicate\n        /* , thisArg */\n        ) {\n          return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n        },\n        findIndex: function findIndex(predicate\n        /* , thisArg */\n        ) {\n          return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n        },\n        forEach: function forEach(callbackfn\n        /* , thisArg */\n        ) {\n          arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n        },\n        indexOf: function indexOf(searchElement\n        /* , fromIndex */\n        ) {\n          return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n        },\n        includes: function includes(searchElement\n        /* , fromIndex */\n        ) {\n          return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n        },\n        join: function join(separator) {\n          // eslint-disable-line no-unused-vars\n          return arrayJoin.apply(validate(this), arguments);\n        },\n        lastIndexOf: function lastIndexOf(searchElement\n        /* , fromIndex */\n        ) {\n          // eslint-disable-line no-unused-vars\n          return arrayLastIndexOf.apply(validate(this), arguments);\n        },\n        map: function map(mapfn\n        /* , thisArg */\n        ) {\n          return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n        },\n        reduce: function reduce(callbackfn\n        /* , initialValue */\n        ) {\n          // eslint-disable-line no-unused-vars\n          return arrayReduce.apply(validate(this), arguments);\n        },\n        reduceRight: function reduceRight(callbackfn\n        /* , initialValue */\n        ) {\n          // eslint-disable-line no-unused-vars\n          return arrayReduceRight.apply(validate(this), arguments);\n        },\n        reverse: function reverse() {\n          var that = this;\n          var length = validate(that).length;\n          var middle = Math.floor(length / 2);\n          var index = 0;\n          var value;\n\n          while (index < middle) {\n            value = that[index];\n            that[index++] = that[--length];\n            that[length] = value;\n          }\n\n          return that;\n        },\n        some: function some(callbackfn\n        /* , thisArg */\n        ) {\n          return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n        },\n        sort: function sort(comparefn) {\n          return arraySort.call(validate(this), comparefn);\n        },\n        subarray: function subarray(begin, end) {\n          var O = validate(this);\n          var length = O.length;\n          var $begin = toAbsoluteIndex(begin, length);\n          return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));\n        }\n      };\n\n      var $slice = function slice(start, end) {\n        return speciesFromList(this, arraySlice.call(validate(this), start, end));\n      };\n\n      var $set = function set(arrayLike\n      /* , offset */\n      ) {\n        validate(this);\n        var offset = toOffset(arguments[1], 1);\n        var length = this.length;\n        var src = toObject(arrayLike);\n        var len = toLength(src.length);\n        var index = 0;\n        if (len + offset > length) throw RangeError(WRONG_LENGTH);\n\n        while (index < len) this[offset + index] = src[index++];\n      };\n\n      var $iterators = {\n        entries: function entries() {\n          return arrayEntries.call(validate(this));\n        },\n        keys: function keys() {\n          return arrayKeys.call(validate(this));\n        },\n        values: function values() {\n          return arrayValues.call(validate(this));\n        }\n      };\n\n      var isTAIndex = function (target, key) {\n        return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);\n      };\n\n      var $getDesc = function getOwnPropertyDescriptor(target, key) {\n        return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);\n      };\n\n      var $setDesc = function defineProperty(target, key, desc) {\n        if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors\n        && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {\n          target[key] = desc.value;\n          return target;\n        }\n\n        return dP(target, key, desc);\n      };\n\n      if (!ALL_CONSTRUCTORS) {\n        $GOPD.f = $getDesc;\n        $DP.f = $setDesc;\n      }\n\n      $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n        getOwnPropertyDescriptor: $getDesc,\n        defineProperty: $setDesc\n      });\n\n      if (fails(function () {\n        arrayToString.call({});\n      })) {\n        arrayToString = arrayToLocaleString = function toString() {\n          return arrayJoin.call(this);\n        };\n      }\n\n      var $TypedArrayPrototype$ = redefineAll({}, proto);\n      redefineAll($TypedArrayPrototype$, $iterators);\n      hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n      redefineAll($TypedArrayPrototype$, {\n        slice: $slice,\n        set: $set,\n        constructor: function () {\n          /* noop */\n        },\n        toString: arrayToString,\n        toLocaleString: $toLocaleString\n      });\n      addGetter($TypedArrayPrototype$, 'buffer', 'b');\n      addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n      addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n      addGetter($TypedArrayPrototype$, 'length', 'e');\n      dP($TypedArrayPrototype$, TAG, {\n        get: function () {\n          return this[TYPED_ARRAY];\n        }\n      }); // eslint-disable-next-line max-statements\n\n      module.exports = function (KEY, BYTES, wrapper, CLAMPED) {\n        CLAMPED = !!CLAMPED;\n        var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';\n        var GETTER = 'get' + KEY;\n        var SETTER = 'set' + KEY;\n        var TypedArray = global[NAME];\n        var Base = TypedArray || {};\n        var TAC = TypedArray && getPrototypeOf(TypedArray);\n        var FORCED = !TypedArray || !$typed.ABV;\n        var O = {};\n        var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n\n        var getter = function (that, index) {\n          var data = that._d;\n          return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n        };\n\n        var setter = function (that, index, value) {\n          var data = that._d;\n          if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n          data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n        };\n\n        var addElement = function (that, index) {\n          dP(that, index, {\n            get: function () {\n              return getter(this, index);\n            },\n            set: function (value) {\n              return setter(this, index, value);\n            },\n            enumerable: true\n          });\n        };\n\n        if (FORCED) {\n          TypedArray = wrapper(function (that, data, $offset, $length) {\n            anInstance(that, TypedArray, NAME, '_d');\n            var index = 0;\n            var offset = 0;\n            var buffer, byteLength, length, klass;\n\n            if (!isObject(data)) {\n              length = toIndex(data);\n              byteLength = length * BYTES;\n              buffer = new $ArrayBuffer(byteLength);\n            } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n              buffer = data;\n              offset = toOffset($offset, BYTES);\n              var $len = data.byteLength;\n\n              if ($length === undefined) {\n                if ($len % BYTES) throw RangeError(WRONG_LENGTH);\n                byteLength = $len - offset;\n                if (byteLength < 0) throw RangeError(WRONG_LENGTH);\n              } else {\n                byteLength = toLength($length) * BYTES;\n                if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);\n              }\n\n              length = byteLength / BYTES;\n            } else if (TYPED_ARRAY in data) {\n              return fromList(TypedArray, data);\n            } else {\n              return $from.call(TypedArray, data);\n            }\n\n            hide(that, '_d', {\n              b: buffer,\n              o: offset,\n              l: byteLength,\n              e: length,\n              v: new $DataView(buffer)\n            });\n\n            while (index < length) addElement(that, index++);\n          });\n          TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n          hide(TypedArrayPrototype, 'constructor', TypedArray);\n        } else if (!fails(function () {\n          TypedArray(1);\n        }) || !fails(function () {\n          new TypedArray(-1); // eslint-disable-line no-new\n        }) || !$iterDetect(function (iter) {\n          new TypedArray(); // eslint-disable-line no-new\n\n          new TypedArray(null); // eslint-disable-line no-new\n\n          new TypedArray(1.5); // eslint-disable-line no-new\n\n          new TypedArray(iter); // eslint-disable-line no-new\n        }, true)) {\n          TypedArray = wrapper(function (that, data, $offset, $length) {\n            anInstance(that, TypedArray, NAME);\n            var klass; // `ws` module bug, temporarily remove validation length for Uint8Array\n            // https://github.com/websockets/ws/pull/645\n\n            if (!isObject(data)) return new Base(toIndex(data));\n\n            if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n              return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);\n            }\n\n            if (TYPED_ARRAY in data) return fromList(TypedArray, data);\n            return $from.call(TypedArray, data);\n          });\n          arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {\n            if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);\n          });\n          TypedArray[PROTOTYPE] = TypedArrayPrototype;\n          if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;\n        }\n\n        var $nativeIterator = TypedArrayPrototype[ITERATOR];\n        var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);\n        var $iterator = $iterators.values;\n        hide(TypedArray, TYPED_CONSTRUCTOR, true);\n        hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n        hide(TypedArrayPrototype, VIEW, true);\n        hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n        if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {\n          dP(TypedArrayPrototype, TAG, {\n            get: function () {\n              return NAME;\n            }\n          });\n        }\n\n        O[NAME] = TypedArray;\n        $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n        $export($export.S, NAME, {\n          BYTES_PER_ELEMENT: BYTES\n        });\n        $export($export.S + $export.F * fails(function () {\n          Base.of.call(TypedArray, 1);\n        }), NAME, {\n          from: $from,\n          of: $of\n        });\n        if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n        $export($export.P, NAME, proto);\n        setSpecies(NAME);\n        $export($export.P + $export.F * FORCED_SET, NAME, {\n          set: $set\n        });\n        $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n        if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;\n        $export($export.P + $export.F * fails(function () {\n          new TypedArray(1).slice();\n        }), NAME, {\n          slice: $slice\n        });\n        $export($export.P + $export.F * (fails(function () {\n          return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();\n        }) || !fails(function () {\n          TypedArrayPrototype.toLocaleString.call([1, 2]);\n        })), NAME, {\n          toLocaleString: $toLocaleString\n        });\n        Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n        if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);\n      };\n    } else module.exports = function () {\n      /* empty */\n    };\n  });\n\n  _typedArray('Uint8', 1, function (init) {\n    return function Uint8Array(data, byteOffset, length) {\n      return init(this, data, byteOffset, length);\n    };\n  });\n\n  var axios = require(\"axios\");\n\n  var atob = require(\"atob\");\n\n  var nacl = require(\"tweetnacl\");\n\n  var url = require(\"url\");\n\n  var WebSocket = require(\"websocket\");\n\n  var WebSocketClient = WebSocket.w3cwebsocket;\n  var TAG_NOP = 0;\n  var TAG_TRANSFER = 1;\n  var TAG_CONTRACT = 2;\n  var TAG_STAKE = 3;\n  var TAG_BATCH = 4;\n\n  var JSBI = require('jsbi');\n\n  if (typeof window$1 === 'undefined') {\n    var window$1 = window$1 || {};\n  }\n\n  var BigInt = window$1 && window$1.useNativeBigIntsIfAvailable ? BigInt : JSBI.BigInt;\n  /**\n   * Converts a string to a Buffer.\n   *\n   * @param {string} str\n   * @returns {ArrayBuffer}\n   */\n\n  var str2ab = function str2ab(str) {\n    var buf = new ArrayBuffer(str.length);\n    var view = new Uint8Array(buf);\n\n    for (var i = 0, len = str.length; i < len; i++) {\n      view[i] = str.charCodeAt(i);\n    }\n\n    return buf;\n  };\n\n  DataView.prototype._setBigUint64 = DataView.prototype.setBigUint64;\n\n  DataView.prototype.setBigUint64 = function (byteOffset, value, littleEndian) {\n    if (typeof value === 'bigint' && typeof this._setBigUint64 !== 'undefined') {\n      this._setBigUint64(byteOffset, value, littleEndian);\n    } else if (value.constructor === JSBI && typeof value.sign === 'bigint' && typeof this._setBigUint64 !== 'undefined') {\n      this._setBigUint64(byteOffset, value.sign, littleEndian);\n    } else if (value.constructor === JSBI || value.constructor && typeof value.constructor.BigInt === 'function') {\n      var lowWord = value[0],\n          highWord = value.length >= 2 ? value[1] : 0;\n      this.setUint32(littleEndian ? byteOffset : byteOffset + 4, lowWord, littleEndian);\n      this.setUint32(littleEndian ? byteOffset + 4 : byteOffset, highWord, littleEndian);\n    } else {\n      throw TypeError('Value needs to be BigInt or JSBI');\n    }\n  };\n\n  DataView.prototype._getBigUint64 = DataView.prototype.getBigUint64;\n\n  DataView.prototype.getBigUint64 = function (byteOffset, littleEndian) {\n    if (typeof this._getBigUint64 !== 'undefined' && window$1.useNativeBigIntsIfAvailable) {\n      return this._getBigUint64(byteOffset, littleEndian);\n    } else {\n      var lowWord = this.getUint32(littleEndian ? byteOffset : byteOffset + 4, littleEndian);\n      var highWord = this.getUint32(littleEndian ? byteOffset + 4 : byteOffset, littleEndian);\n      var result = new JSBI(2, false);\n\n      result.__setDigit(0, lowWord);\n\n      result.__setDigit(1, highWord);\n\n      return result;\n    }\n  };\n\n  if (!global.TextDecoder) {\n    global.TextDecoder = require(\"util\").TextDecoder;\n  }\n\n  if (!ArrayBuffer.transfer) {\n    // Polyfill just in-case.\n\n    /**\n     * The static ArrayBuffer.transfer() method returns a new ArrayBuffer whose contents have\n     * been taken from the oldBuffer's data and then is either truncated or zero-extended by\n     * newByteLength. If newByteLength is undefined, the byteLength of the oldBuffer is used.\n     *\n     * This operation leaves oldBuffer in a detached state.\n     *\n     * @param {Uint8Array} oldBuffer\n     * @param {number} newByteLength\n     * @returns {ArrayBufferLike}\n     */\n    ArrayBuffer.transfer = function (oldBuffer, newByteLength) {\n      if (!(oldBuffer instanceof ArrayBuffer)) throw new TypeError('Source must be an instance of ArrayBuffer');\n      if (newByteLength <= oldBuffer.byteLength) return oldBuffer.slice(0, newByteLength);\n      var destView = new Uint8Array(new ArrayBuffer(newByteLength));\n      destView.set(new Uint8Array(oldBuffer));\n      return destView.buffer;\n    };\n  }\n\n  var PayloadBuilder =\n  /*#__PURE__*/\n  function () {\n    /**\n     * A payload builder made for easier handling of binary serialization of\n     * data for Wavelet to ingest.\n     */\n    function PayloadBuilder() {\n      _classCallCheck(this, PayloadBuilder);\n\n      this.buf = new ArrayBuffer(0);\n      this.view = new DataView(this.buf);\n      this.offset = 0;\n    }\n    /**\n     * Resizes the underlying buffer should it not be large enough to handle\n     * some chunk of data to be appended to buffer.\n     *\n     * @param {number} size Size of data to be appended to the buffer.\n     */\n\n\n    _createClass(PayloadBuilder, [{\n      key: \"resizeIfNeeded\",\n      value: function resizeIfNeeded(size) {\n        if (this.offset + size > this.buf.byteLength) {\n          this.buf = ArrayBuffer.transfer(this.buf, this.offset + size);\n          this.view = new DataView(this.buf);\n        }\n      }\n      /**\n       * Write a single byte to the payload buffer.\n       *\n       * @param {number} n A single byte.\n       */\n\n    }, {\n      key: \"writeByte\",\n      value: function writeByte(n) {\n        this.resizeIfNeeded(1);\n        this.view.setUint8(this.offset, n);\n        this.offset += 1;\n      }\n      /**\n       * Write an signed little-endian 16-bit integer to the payload buffer.\n       *\n       * @param {number} n\n       */\n\n    }, {\n      key: \"writeInt16\",\n      value: function writeInt16(n) {\n        this.resizeIfNeeded(2);\n        this.view.setInt16(this.offset, n, true);\n        this.offset += 2;\n      }\n      /**\n       * Write an signed little-endian 32-bit integer to the payload buffer.\n       *\n       * @param {number} n\n       */\n\n    }, {\n      key: \"writeInt32\",\n      value: function writeInt32(n) {\n        this.resizeIfNeeded(4);\n        this.view.setInt32(this.offset, n, true);\n        this.offset += 4;\n      }\n      /**\n       * Write a signed little-endian 64-bit integer to the payload buffer.\n       *\n       * @param {bigint} n\n       */\n\n    }, {\n      key: \"writeInt64\",\n      value: function writeInt64(n) {\n        this.resizeIfNeeded(8);\n        this.view.setBigInt64(this.offset, n, true);\n        this.offset += 8;\n      }\n      /**\n       * Write an unsigned little-endian 16-bit integer to the payload buffer.\n       *\n       * @param {number} n\n       */\n\n    }, {\n      key: \"writeUint16\",\n      value: function writeUint16(n) {\n        this.resizeIfNeeded(2);\n        this.view.setUint16(this.offset, n, true);\n        this.offset += 2;\n      }\n      /**\n       * Write an unsigned little-endian 32-bit integer to the payload buffer.\n       *\n       * @param {number} n\n       */\n\n    }, {\n      key: \"writeUint32\",\n      value: function writeUint32(n) {\n        this.resizeIfNeeded(4);\n        this.view.setUint32(this.offset, n, true);\n        this.offset += 4;\n      }\n      /**\n       * Write an unsigned little-endian 64-bit integer to the payload buffer.\n       *\n       * @param {bigint} n\n       */\n\n    }, {\n      key: \"writeUint64\",\n      value: function writeUint64(n) {\n        this.resizeIfNeeded(8);\n        this.view.setBigUint64(this.offset, n, true);\n        this.offset += 8;\n      }\n      /**\n       * Write a series of bytes to the payload buffer.\n       *\n       * @param {ArrayBufferLike} buf\n       */\n\n    }, {\n      key: \"writeBytes\",\n      value: function writeBytes(buf) {\n        this.resizeIfNeeded(buf.byteLength);\n        new Uint8Array(this.buf, this.offset, buf.byteLength).set(buf);\n        this.offset += buf.byteLength;\n      }\n      /**\n       * Returns the raw bytes of the payload buffer.\n       *\n       * @returns {Uint8Array}\n       */\n\n    }, {\n      key: \"getBytes\",\n      value: function getBytes() {\n        return new Uint8Array(this.buf.slice(0, this.offset));\n      }\n    }]);\n\n    return PayloadBuilder;\n  }();\n\n  var Contract =\n  /*#__PURE__*/\n  function () {\n    /**\n     * A Wavelet smart contract execution simulator.\n     *\n     * @param {Wavelet} client Client instance which is connected to a single Wavelet node.\n     * @param {string} contract_id Hex-encoded ID of a smart contract.\n     */\n    function Contract(client, contract_id) {\n      _classCallCheck(this, Contract);\n\n      this.client = client;\n      this.contract_id = contract_id;\n      this.contract_payload = {\n        round_idx: BigInt(0),\n        round_id: \"0000000000000000000000000000000000000000000000000000000000000000\",\n        transaction_id: \"0000000000000000000000000000000000000000000000000000000000000000\",\n        sender_id: \"0000000000000000000000000000000000000000000000000000000000000000\",\n        amount: BigInt(0),\n        params: new Uint8Array(new ArrayBuffer(0))\n      };\n      this.decoder = new TextDecoder();\n      this.result = null;\n      this.logs = [];\n      this.rebuildContractPayload();\n    }\n    /**\n     * Sets the consensus round index for all future simulated smart contract calls.\n     *\n     * @param {bigint} round_idx Consensus round index.\n     */\n\n\n    _createClass(Contract, [{\n      key: \"setRoundIndex\",\n      value: function setRoundIndex(round_idx) {\n        this.contract_payload.round_idx = round_idx;\n      }\n      /**\n       * Sets the consensus round ID for all future simulated smart contract calls.\n       *\n       * @param {string} round_id A 64-letter hex-encoded consensus round ID.\n       */\n\n    }, {\n      key: \"setRoundID\",\n      value: function setRoundID(round_id) {\n        if (round_id.length !== 64) throw new Error(\"round id must be 64 letters and hex-encoded\");\n        this.contract_payload.round_id = round_id;\n      }\n      /**\n       * Sets the ID of the transaction used to make all future simulated smart contract calls.\n       *\n       * @param {string} transaction_id A 64-letter ex-encoded transaction ID.\n       */\n\n    }, {\n      key: \"setTransactionID\",\n      value: function setTransactionID(transaction_id) {\n        if (transaction_id.length !== 64) throw new Error(\"transaction id must be 64 letters and hex-encoded\");\n        this.contract_payload.transaction_id = transaction_id;\n      }\n      /**\n       * Sets the sender ID for all future simulated smart contract calls.\n       *\n       * @param {string} sender_id A 64-letter hex-encoded sender wallet address ID.\n       */\n\n    }, {\n      key: \"setSenderID\",\n      value: function setSenderID(sender_id) {\n        if (sender_id.length !== 64) throw new Error(\"sender id must be 64 letters and hex-encoded\");\n        this.contract_payload.sender_id = sender_id;\n      }\n      /**\n       * Simulates a call to the smart contract. init() must be called to initialize the WebAssembly VM\n       * before calls may be performed against this specified smart contract.\n       *\n       * @param {string} func_name Name of the smart contract function to call.\n       * @param {bigint} amount_to_send Amount of PERLs to send simultaneously to the smart contract\n       *  while calling a function.\n       * @param {...{type: ('int16'|'int32'|'int64'|'uint16'|'uint32'|'uint64'|'byte'|'raw'|'bytes'|'string'), value: number|string|ArrayBuffer|Uint8Array}} func_params Variadic list of arguments.\n       * @returns {{result: string|undefined, logs: Array<string>}}\n       */\n\n    }, {\n      key: \"test\",\n      value: function test(wallet, func_name, amount_to_send) {\n        if (this.vm === undefined) throw new Error(\"init() needs to be called before calling test()\");\n        func_name = \"_contract_\" + func_name;\n\n        if (!(func_name in this.vm.instance.exports)) {\n          throw new Error(\"could not find function in smart contract\");\n        }\n\n        for (var _len = arguments.length, func_params = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n          func_params[_key - 3] = arguments[_key];\n        }\n\n        this.contract_payload.params = this.parseFunctionParams.apply(this, func_params);\n        this.contract_payload.amount = amount_to_send;\n        this.contract_payload.sender_id = Buffer.from(wallet.publicKey).toString(\"hex\");\n        this.rebuildContractPayload(); // Clone the current browser VM's memory.\n\n        var copy = ArrayBuffer.transfer(this.vm.instance.exports.memory.buffer, this.vm.instance.exports.memory.buffer.byteLength); // Call the function.\n\n        this.vm.instance.exports[func_name](); // Collect simulated execution results.\n\n        var res = {\n          result: this.result,\n          logs: this.logs\n        }; // Reset the browser VM.\n\n        new Uint8Array(this.vm.instance.exports.memory.buffer, 0, copy.byteLength).set(copy); // Reset all func_params and results and logs.\n\n        this.contract_payload.params = new Uint8Array(new ArrayBuffer(0));\n        this.result = null;\n        this.logs = [];\n        return res;\n      }\n      /**\n       * Performs an official call to a specified smart contract function with a provided gas limit, and a variadic list\n       * of arguments under a provided Wavelet wallet instance.\n       *\n       * @param wallet Wavelet wallet.\n       * @param func_name Name of the smart contract function to call.\n       * @param amount_to_send Amount of PERLs to send simultaneously to the smart contract while\n       * calling a function.\n       * @param gas_limit Gas limit to expend for invoking a smart contract function.\n       * @param gas_deposit Amount of gas fees to deposit into the smart contract.\n       * @param {...{type: ('int16'|'int32'|'int64'|'uint16'|'uint32'|'uint64'|'byte'|'raw'|'bytes'|'string'), value: number|string|ArrayBuffer|Uint8Array}} func_params Variadic list of arguments.\n       * @returns {Promise<Object>} Response from the Wavelet node.\n       */\n\n    }, {\n      key: \"call\",\n      value: function () {\n        var _call = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee(wallet, func_name, amount_to_send, gas_limit, gas_deposit) {\n          var _len2,\n              func_params,\n              _key2,\n              _args = arguments;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  for (_len2 = _args.length, func_params = new Array(_len2 > 5 ? _len2 - 5 : 0), _key2 = 5; _key2 < _len2; _key2++) {\n                    func_params[_key2 - 5] = _args[_key2];\n                  }\n\n                  _context.next = 3;\n                  return this.client.transfer(wallet, this.contract_id, amount_to_send, gas_limit, gas_deposit, func_name, this.parseFunctionParams.apply(this, func_params));\n\n                case 3:\n                  return _context.abrupt(\"return\", _context.sent);\n\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function call(_x, _x2, _x3, _x4, _x5) {\n          return _call.apply(this, arguments);\n        }\n\n        return call;\n      }()\n      /**\n       * Parses smart contract function parameters as a variadic list of arguments, and translates\n       * them into an array of bytes suitable for passing on to a single smart contract invocation call.\n       *\n       * @param {...{type: ('int16'|'int32'|'int64'|'uint16'|'uint32'|'uint64'|'byte'|'raw'|'bytes'|'string'), value: number|string|ArrayBuffer|Uint8Array}} params Variadic list of arguments.\n       * @returns {Uint8Array} Parameters serialized into bytes.\n       */\n\n    }, {\n      key: \"parseFunctionParams\",\n      value: function parseFunctionParams() {\n        var builder = new PayloadBuilder();\n\n        for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          params[_key3] = arguments[_key3];\n        }\n\n        params.forEach(function (param) {\n          switch (param.type) {\n            case \"int16\":\n              builder.writeInt16(param.value);\n              break;\n\n            case \"int32\":\n              builder.writeInt32(param.value);\n              break;\n\n            case \"int64\":\n              builder.writeInt64(param.value);\n\n            case \"uint16\":\n              builder.writeUint16(param.value);\n              break;\n\n            case \"uint32\":\n              builder.writeUint32(param.value);\n              break;\n\n            case \"uint64\":\n              builder.writeUint64(param.value);\n              break;\n\n            case \"byte\":\n              builder.writeByte(param.value);\n              break;\n\n            case \"raw\":\n              if (typeof param.value === \"string\") {\n                // Assume that it is hex-encoded.\n                param.value = new Uint8Array(param.value.match(/[\\da-f]{2}/gi).map(function (h) {\n                  return parseInt(h, 16);\n                }));\n              }\n\n              builder.writeBytes(param.value);\n              break;\n\n            case \"bytes\":\n              if (typeof param.value === \"string\") {\n                // Assume that it is hex-encoded.\n                param.value = new Uint8Array(param.value.match(/[\\da-f]{2}/gi).map(function (h) {\n                  return parseInt(h, 16);\n                }));\n              }\n\n              builder.writeUint32(param.value.byteLength);\n              builder.writeBytes(param.value);\n              break;\n\n            case \"string\":\n              builder.writeBytes(Buffer.from(param.value, 'utf8'));\n              builder.writeByte(0);\n              break;\n          }\n        });\n        return builder.getBytes();\n      }\n      /**\n       * Based on updates to simulation settings for this smart contract, re-build the\n       * smart contracts payload.\n       */\n\n    }, {\n      key: \"rebuildContractPayload\",\n      value: function rebuildContractPayload() {\n        var builder = new PayloadBuilder();\n        builder.writeUint64(this.contract_payload.round_idx);\n        builder.writeBytes(Buffer.from(this.contract_payload.round_id, \"hex\"));\n        builder.writeBytes(Buffer.from(this.contract_payload.transaction_id, \"hex\"));\n        builder.writeBytes(Buffer.from(this.contract_payload.sender_id, \"hex\"));\n        builder.writeUint64(this.contract_payload.amount);\n        builder.writeBytes(this.contract_payload.params);\n        this.contract_payload_buf = builder.getBytes();\n      }\n      /**\n       * Fetches and re-loads the memory of the backing WebAssembly VM for this smart contract; optionally\n       * growing the number of memory pages associated to the VM should there be not enough memory to hold\n       * any new updates to the smart contracts memory. init() must be called before this function may be\n       * called.\n       *\n       * @returns {Promise<void>}\n       */\n\n    }, {\n      key: \"fetchAndPopulateMemoryPages\",\n      value: function () {\n        var _fetchAndPopulateMemoryPages = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee2() {\n          var account, loaded_memory, num_mem_pages, num_loaded_mem_pages;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!(this.vm === undefined)) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  throw new Error(\"init() needs to be called before calling fetchAndPopulateMemoryPages()\");\n\n                case 2:\n                  _context2.next = 4;\n                  return this.client.getAccount(this.contract_id);\n\n                case 4:\n                  account = _context2.sent;\n                  _context2.next = 7;\n                  return this.client.getMemoryPages(account.public_key, account.num_mem_pages);\n\n                case 7:\n                  loaded_memory = _context2.sent;\n                  num_mem_pages = this.vm.instance.exports.memory.buffer.byteLength / 65536;\n                  num_loaded_mem_pages = loaded_memory.byteLength / 65536;\n\n                  if (num_mem_pages < num_loaded_mem_pages) {\n                    this.vm.instance.exports.memory.grow(num_loaded_mem_pages - num_mem_pages);\n                  }\n\n                  new Uint8Array(this.vm.instance.exports.memory.buffer, 0, loaded_memory.byteLength).set(loaded_memory);\n\n                case 12:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function fetchAndPopulateMemoryPages() {\n          return _fetchAndPopulateMemoryPages.apply(this, arguments);\n        }\n\n        return fetchAndPopulateMemoryPages;\n      }()\n      /**\n       * Downloads smart contract code from the Wavelet node if available, and initializes\n       * a WebAssembly VM to simulate function calls against the contract.\n       *\n       * @returns {Promise<void>}\n       */\n\n    }, {\n      key: \"init\",\n      value: function () {\n        var _init = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee3() {\n          var _this = this;\n\n          var imports;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return this.client.getCode(this.contract_id);\n\n                case 2:\n                  this.code = _context3.sent;\n                  imports = {\n                    env: {\n                      abort: function abort() {},\n                      _send_transaction: function _send_transaction(tag, payload_ptr, payload_len) {\n                        var payload_view = new Uint8Array(_this.vm.instance.exports.memory.buffer, payload_ptr, payload_len);\n\n                        var payload = _this.decoder.decode(payload_view);\n\n                        console.log(\"Sent transaction with tag \".concat(tag, \" and payload \").concat(params, \".\"));\n                      },\n                      _payload_len: function _payload_len() {\n                        return _this.contract_payload_buf.byteLength;\n                      },\n                      _payload: function _payload(payload_ptr) {\n                        var view = new Uint8Array(_this.vm.instance.exports.memory.buffer, payload_ptr, _this.contract_payload_buf.byteLength);\n                        view.set(_this.contract_payload_buf);\n                      },\n                      _result: function _result(ptr, len) {\n                        _this.result = _this.decoder.decode(new Uint8Array(_this.vm.instance.exports.memory.buffer, ptr, len));\n                      },\n                      _log: function _log(ptr, len) {\n                        var view = new Uint8Array(_this.vm.instance.exports.memory.buffer, ptr, len);\n\n                        _this.logs.push(_this.decoder.decode(view));\n                      },\n                      _verify_ed25519: function _verify_ed25519() {},\n                      _hash_blake2b_256: function _hash_blake2b_256() {},\n                      _hash_sha256: function _hash_sha256() {},\n                      _hash_sha512: function _hash_sha512() {}\n                    }\n                  };\n                  _context3.next = 6;\n                  return WebAssembly.instantiate(this.code, imports);\n\n                case 6:\n                  this.vm = _context3.sent;\n                  _context3.next = 9;\n                  return this.fetchAndPopulateMemoryPages();\n\n                case 9:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n\n        function init() {\n          return _init.apply(this, arguments);\n        }\n\n        return init;\n      }()\n    }]);\n\n    return Contract;\n  }();\n\n  var Wavelet =\n  /*#__PURE__*/\n  function () {\n    /**\n     * A client for interacting with the HTTP API of a Wavelet node.\n     *\n     * @param {string} host Address to the HTTP API of a Wavelet node.\n     * @param {Object=} opts Default options to be passed for making any HTTP request calls using this client instance (optional).\n     */\n    function Wavelet(host) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, Wavelet);\n\n      this.host = host;\n      this.opts = _objectSpread2({}, opts, {\n        transformRequest: [function (data, headers) {\n          headers.common = {};\n          return data;\n        }]\n      });\n    }\n    /**\n     * Query for information about the node you are connected to.\n     *\n     * @param {Object=} opts Options to be passed on for making the specified HTTP request call (optional).\n     * @returns {Promise<Object>}\n     */\n\n\n    _createClass(Wavelet, [{\n      key: \"getNodeInfo\",\n      value: function () {\n        var _getNodeInfo = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee4(opts) {\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return axios.get(\"\".concat(this.host, \"/ledger\"), _objectSpread2({}, this.opts, {}, opts));\n\n                case 2:\n                  return _context4.abrupt(\"return\", _context4.sent.data);\n\n                case 3:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n\n        function getNodeInfo(_x6) {\n          return _getNodeInfo.apply(this, arguments);\n        }\n\n        return getNodeInfo;\n      }()\n      /**\n       * Query for details of a transaction.\n       *\n       * @param {string} id Hex-encoded transaction ID.\n       * @param {Object=} opts Options to be passed on for making the specified HTTP request call (optional).\n       * @returns {Promise<Object>}\n       */\n\n    }, {\n      key: \"getTransaction\",\n      value: function () {\n        var _getTransaction = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee5(id) {\n          var opts,\n              _args5 = arguments;\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  opts = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n                  _context5.next = 3;\n                  return axios.get(\"\".concat(this.host, \"/tx/\").concat(id), _objectSpread2({}, this.opts, {}, opts));\n\n                case 3:\n                  return _context5.abrupt(\"return\", _context5.sent.data);\n\n                case 4:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        }));\n\n        function getTransaction(_x7) {\n          return _getTransaction.apply(this, arguments);\n        }\n\n        return getTransaction;\n      }()\n      /**\n       * Query for details of an account; whether it be a smart contract or a user.\n       *\n       * @param {string} id Hex-encoded account/smart contract address.\n       * @param {Object=} opts Options to be passed on for making the specified HTTP request call (optional).\n       * @returns {Promise<{public_key: string, nonce: bigint, balance: bigint, stake: bigint, reward: bigint, is_contract: boolean, num_mem_pages: bigint}>}\n       */\n\n    }, {\n      key: \"getAccount\",\n      value: function () {\n        var _getAccount = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee6(id) {\n          var opts,\n              _args6 = arguments;\n          return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n                  _context6.next = 3;\n                  return axios.get(\"\".concat(this.host, \"/accounts/\").concat(id), _objectSpread2({}, this.opts, {}, opts));\n\n                case 3:\n                  return _context6.abrupt(\"return\", _context6.sent.data);\n\n                case 4:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n\n        function getAccount(_x8) {\n          return _getAccount.apply(this, arguments);\n        }\n\n        return getAccount;\n      }()\n      /**\n       * Query for the raw WebAssembly code of a smart contract.\n       *\n       * @param string} id Hex-encoded ID of the smart contract.\n       * @param {Object=} opts  Options to be passed on for making the specified HTTP request call (optional).\n       * @returns {Promise<Uint8Array>}\n       */\n\n    }, {\n      key: \"getCode\",\n      value: function () {\n        var _getCode = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee7(id) {\n          var opts,\n              _args7 = arguments;\n          return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n                  _context7.t0 = Uint8Array;\n                  _context7.next = 4;\n                  return axios.get(\"\".concat(this.host, \"/contract/\").concat(id), _objectSpread2({}, this.opts, {}, opts, {\n                    responseType: 'arraybuffer',\n                    responseEncoding: 'binary'\n                  }));\n\n                case 4:\n                  _context7.t1 = _context7.sent.data;\n                  return _context7.abrupt(\"return\", new _context7.t0(_context7.t1));\n\n                case 6:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7, this);\n        }));\n\n        function getCode(_x9) {\n          return _getCode.apply(this, arguments);\n        }\n\n        return getCode;\n      }()\n      /**\n       * Query for the amalgamated WebAssembly VM memory of a given smart contract.\n       *\n       * @param {string} id Hex-encoded ID of the smart contract.\n       * @param {number} num_mem_pages Number of memory pages the smart contract has.\n       * @param {Object=} opts  Options to be passed on for making the specified HTTP request call (optional).\n       * @returns {Promise<Uint8Array>} The memory of the given smart contract, which may be used to\n       *  initialize a WebAssembly VM with (either on browser/desktop).\n       */\n\n    }, {\n      key: \"getMemoryPages\",\n      value: function () {\n        var _getMemoryPages = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee9(id, num_mem_pages) {\n          var _this2 = this;\n\n          var opts,\n              memory,\n              reqs,\n              _loop,\n              idx,\n              _args9 = arguments;\n\n          return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n            while (1) {\n              switch (_context9.prev = _context9.next) {\n                case 0:\n                  opts = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : {};\n\n                  if (!(num_mem_pages === 0)) {\n                    _context9.next = 3;\n                    break;\n                  }\n\n                  throw new Error(\"num pages cannot be zero\");\n\n                case 3:\n                  memory = new Uint8Array(new ArrayBuffer(65536 * num_mem_pages));\n                  reqs = [];\n\n                  _loop = function _loop(idx) {\n                    reqs.push(_asyncToGenerator(\n                    /*#__PURE__*/\n                    _regeneratorRuntime.mark(function _callee8() {\n                      var res, page;\n                      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n                        while (1) {\n                          switch (_context8.prev = _context8.next) {\n                            case 0:\n                              _context8.prev = 0;\n                              _context8.next = 3;\n                              return axios.get(\"\".concat(_this2.host, \"/contract/\").concat(id, \"/page/\").concat(idx), _objectSpread2({}, _this2.opts, {}, opts, {\n                                responseType: 'arraybuffer',\n                                responseEncoding: 'binary'\n                              }));\n\n                            case 3:\n                              res = _context8.sent;\n\n                              if (res.status === 200) {\n                                page = new Uint8Array(res.data);\n                                memory.set(page, 65536 * idx);\n                              }\n\n                              _context8.next = 9;\n                              break;\n\n                            case 7:\n                              _context8.prev = 7;\n                              _context8.t0 = _context8[\"catch\"](0);\n\n                            case 9:\n                            case \"end\":\n                              return _context8.stop();\n                          }\n                        }\n                      }, _callee8, null, [[0, 7]]);\n                    }))());\n                  };\n\n                  for (idx = 0; idx < num_mem_pages; idx++) {\n                    _loop(idx);\n                  }\n\n                  _context9.next = 9;\n                  return Promise.all(reqs);\n\n                case 9:\n                  return _context9.abrupt(\"return\", memory);\n\n                case 10:\n                case \"end\":\n                  return _context9.stop();\n              }\n            }\n          }, _callee9);\n        }));\n\n        function getMemoryPages(_x10, _x11) {\n          return _getMemoryPages.apply(this, arguments);\n        }\n\n        return getMemoryPages;\n      }()\n      /**\n       * Transfer some amount of PERLs to a recipient, or invoke a function on\n       * a smart contract should the recipient specified be a smart contract.\n       *\n       * @param {nacl.SignKeyPair} wallet\n       * @param {string} recipient Hex-encoded recipient/smart contract address.\n       * @param {bigint} amount Amount of PERLs to send.\n       * @param {bigint=} gas_limit Gas limit to expend for invoking a smart contract function (optional).\n       * @param {bigint=} gas_deposit Amount of gas to deposit into a smart contract (optional).\n       * @param {string=} func_name Name of the function to invoke on a smart contract (optional).\n       * @param {Uint8Array=} func_payload Binary-serialized parameters to be used to invoke a smart contract function (optional).\n       * @param {Object=} opts Options to be passed on for making the specified HTTP request call (optional).\n       * @returns {Promise<Object>}\n       */\n\n    }, {\n      key: \"transfer\",\n      value: function () {\n        var _transfer = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee10(wallet, recipient, amount) {\n          var gas_limit,\n              gas_deposit,\n              func_name,\n              func_payload,\n              opts,\n              builder,\n              func_name_buf,\n              func_payload_buf,\n              _args10 = arguments;\n          return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n            while (1) {\n              switch (_context10.prev = _context10.next) {\n                case 0:\n                  gas_limit = _args10.length > 3 && _args10[3] !== undefined ? _args10[3] : 0;\n                  gas_deposit = _args10.length > 4 && _args10[4] !== undefined ? _args10[4] : 0;\n                  func_name = _args10.length > 5 && _args10[5] !== undefined ? _args10[5] : \"\";\n                  func_payload = _args10.length > 6 && _args10[6] !== undefined ? _args10[6] : new Uint8Array(new ArrayBuffer(0));\n                  opts = _args10.length > 7 && _args10[7] !== undefined ? _args10[7] : {};\n                  builder = new PayloadBuilder();\n                  builder.writeBytes(Buffer.from(recipient, \"hex\"));\n                  builder.writeUint64(amount);\n\n                  if (JSBI.GT(gas_limit, BigInt(0)) || func_name.length > 0 || func_payload.length > 0) {\n                    if (func_name.length === 0) {\n                      // Default to 'on_money_received' if no func name is specified.\n                      func_name = \"on_money_received\";\n                    }\n\n                    func_name_buf = Buffer.from(func_name, 'utf8');\n                    func_payload_buf = new Uint8Array(func_payload);\n                    builder.writeUint64(gas_limit);\n                    builder.writeUint64(gas_deposit);\n                    builder.writeUint32(func_name_buf.byteLength);\n                    builder.writeBytes(func_name_buf);\n                    builder.writeUint32(func_payload_buf.byteLength);\n                    builder.writeBytes(func_payload_buf);\n                  }\n\n                  _context10.next = 11;\n                  return this.sendTransaction(wallet, TAG_TRANSFER, builder.getBytes(), opts);\n\n                case 11:\n                  return _context10.abrupt(\"return\", _context10.sent);\n\n                case 12:\n                case \"end\":\n                  return _context10.stop();\n              }\n            }\n          }, _callee10, this);\n        }));\n\n        function transfer(_x12, _x13, _x14) {\n          return _transfer.apply(this, arguments);\n        }\n\n        return transfer;\n      }()\n      /**\n       * Stake some amount of PERLs which is deducted from your wallets balance.\n       *\n       * @param {nacl.SignKeyPair} wallet Wavelet wallet.\n       * @param {bigint} amount Amount of PERLs to stake.\n       * @param {Object=} opts Options to be passed on for making the specified HTTP request call (optional).\n       * @returns {Promise<*>}\n       */\n\n    }, {\n      key: \"placeStake\",\n      value: function () {\n        var _placeStake = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee11(wallet, amount) {\n          var opts,\n              builder,\n              _args11 = arguments;\n          return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  opts = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : {};\n                  builder = new PayloadBuilder();\n                  builder.writeByte(1);\n                  builder.writeUint64(amount);\n                  _context11.next = 6;\n                  return this.sendTransaction(wallet, TAG_STAKE, builder.getBytes(), opts);\n\n                case 6:\n                  return _context11.abrupt(\"return\", _context11.sent);\n\n                case 7:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }, _callee11, this);\n        }));\n\n        function placeStake(_x15, _x16) {\n          return _placeStake.apply(this, arguments);\n        }\n\n        return placeStake;\n      }()\n      /**\n       * Withdraw stake, which is immediately converted into PERLS into your balance.\n       *\n       * @param {nacl.SignKeyPair} wallet Wavelet wallet.\n       * @param {bigint} amount Amount of PERLs to withdraw from your stake.\n       * @param {Object=} opts Options to be passed on for making the specified HTTP request call (optional).\n       * @returns {Promise<*>}\n       */\n\n    }, {\n      key: \"withdrawStake\",\n      value: function () {\n        var _withdrawStake = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee12(wallet, amount) {\n          var opts,\n              builder,\n              _args12 = arguments;\n          return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n            while (1) {\n              switch (_context12.prev = _context12.next) {\n                case 0:\n                  opts = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : {};\n                  builder = new PayloadBuilder();\n                  builder.writeByte(0);\n                  builder.writeUint64(amount);\n                  _context12.next = 6;\n                  return this.sendTransaction(wallet, TAG_STAKE, builder.getBytes(), opts);\n\n                case 6:\n                  return _context12.abrupt(\"return\", _context12.sent);\n\n                case 7:\n                case \"end\":\n                  return _context12.stop();\n              }\n            }\n          }, _callee12, this);\n        }));\n\n        function withdrawStake(_x17, _x18) {\n          return _withdrawStake.apply(this, arguments);\n        }\n\n        return withdrawStake;\n      }()\n      /**\n       * Request a withdrawal of reward; which after some number of consensus\n       * rounds will then convert into PERLs into your balance.\n       *\n       * @param {nacl.SignKeyPair} wallet Wavelet wallet.\n       * @param {bigint} amount Amount of PERLs to request to withdraw from your rewards.\n       * @param {Object=} opts Options to be passed on for making the specified HTTP request call (optional).\n       * @returns {Promise<*>}\n       */\n\n    }, {\n      key: \"withdrawReward\",\n      value: function () {\n        var _withdrawReward = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee13(wallet, amount) {\n          var opts,\n              builder,\n              _args13 = arguments;\n          return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n            while (1) {\n              switch (_context13.prev = _context13.next) {\n                case 0:\n                  opts = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : {};\n                  builder = new PayloadBuilder();\n                  builder.writeByte(2);\n                  builder.writeUint64(amount);\n                  _context13.next = 6;\n                  return this.sendTransaction(wallet, TAG_STAKE, builder.getBytes(), opts);\n\n                case 6:\n                  return _context13.abrupt(\"return\", _context13.sent);\n\n                case 7:\n                case \"end\":\n                  return _context13.stop();\n              }\n            }\n          }, _callee13, this);\n        }));\n\n        function withdrawReward(_x19, _x20) {\n          return _withdrawReward.apply(this, arguments);\n        }\n\n        return withdrawReward;\n      }()\n      /**\n       * Deploy a smart contract with a specified gas limit and set of parameters.\n       *\n       * @param {nacl.SignKeyPair} wallet Wavelet wallet.\n       * @param {Uint8Array} code Binary of your smart contracts WebAssembly code.\n       * @param {bigint} gas_limit Gas limit to expend for creating your smart contract, and invoking its init() function.\n       * @param {bigint=} gas_deposit Amount of gas fees to deposit into a smart contract.\n       * @param {Object=} params Parameters to be used for invoking your smart contracts init() function.\n       * @param {Object=} opts Options to be passed on for making the specified HTTP request call (optional).\n       * @returns {Promise<*>}\n       */\n\n    }, {\n      key: \"deployContract\",\n      value: function () {\n        var _deployContract = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee14(wallet, code, gas_limit) {\n          var gas_deposit,\n              params,\n              opts,\n              builder,\n              _args14 = arguments;\n          return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n            while (1) {\n              switch (_context14.prev = _context14.next) {\n                case 0:\n                  gas_deposit = _args14.length > 3 && _args14[3] !== undefined ? _args14[3] : 0;\n                  params = _args14.length > 4 && _args14[4] !== undefined ? _args14[4] : [];\n                  opts = _args14.length > 5 && _args14[5] !== undefined ? _args14[5] : {};\n                  code = new Uint8Array(code);\n                  params = new Uint8Array(params);\n                  builder = new PayloadBuilder();\n                  builder.writeUint64(gas_limit);\n                  builder.writeUint64(gas_deposit);\n                  builder.writeUint32(params.byteLength);\n                  builder.writeBytes(params);\n                  builder.writeBytes(code);\n                  _context14.next = 13;\n                  return this.sendTransaction(wallet, TAG_CONTRACT, builder.getBytes(), opts);\n\n                case 13:\n                  return _context14.abrupt(\"return\", _context14.sent);\n\n                case 14:\n                case \"end\":\n                  return _context14.stop();\n              }\n            }\n          }, _callee14, this);\n        }));\n\n        function deployContract(_x21, _x22, _x23) {\n          return _deployContract.apply(this, arguments);\n        }\n\n        return deployContract;\n      }()\n      /**\n       * Send a transaction on behalf of a specified wallet with a designated\n       * tag and payload.\n       *\n       * @param {nacl.SignKeyPair} wallet Wavelet wallet.\n       * @param {number} tag Tag of the transaction.\n       * @param {Uint8Array} payload Binary payload of the transaction.\n       * @param {Object=} opts Options to be passed on for making the specified HTTP request call (optional).\n       * @returns {Promise<*>}\n       */\n\n    }, {\n      key: \"sendTransaction\",\n      value: function () {\n        var _sendTransaction = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee15(wallet, tag, payload) {\n          var opts,\n              payload_hex,\n              builder,\n              signature,\n              sender,\n              req,\n              _args15 = arguments;\n          return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n            while (1) {\n              switch (_context15.prev = _context15.next) {\n                case 0:\n                  opts = _args15.length > 3 && _args15[3] !== undefined ? _args15[3] : {};\n                  payload_hex = Buffer.from(payload).toString(\"hex\");\n                  builder = new PayloadBuilder();\n                  builder.writeUint64(BigInt(0));\n                  builder.writeByte(tag);\n                  builder.writeBytes(payload);\n                  signature = Buffer.from(nacl.sign.detached(builder.getBytes(), wallet.secretKey)).toString(\"hex\");\n                  sender = Buffer.from(wallet.publicKey).toString(\"hex\");\n                  req = {\n                    sender: sender,\n                    tag: tag,\n                    payload: payload_hex,\n                    signature: signature\n                  };\n                  _context15.next = 11;\n                  return axios.post(\"\".concat(this.host, \"/tx/send\"), JSON.stringify(req), _objectSpread2({}, this.opts, {}, opts));\n\n                case 11:\n                  return _context15.abrupt(\"return\", _context15.sent.data);\n\n                case 12:\n                case \"end\":\n                  return _context15.stop();\n              }\n            }\n          }, _callee15, this);\n        }));\n\n        function sendTransaction(_x24, _x25, _x26) {\n          return _sendTransaction.apply(this, arguments);\n        }\n\n        return sendTransaction;\n      }()\n      /**\n       * Poll for updates to accounts.\n       *\n       * @param callbacks\n       * @param {{id: string|undefined}} opts\n       * @returns {Promise<WebSocketClient>} Websocket client.\n       */\n\n    }, {\n      key: \"pollAccounts\",\n      value: function () {\n        var _pollAccounts = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee16() {\n          var callbacks,\n              opts,\n              params,\n              _args16 = arguments;\n          return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n            while (1) {\n              switch (_context16.prev = _context16.next) {\n                case 0:\n                  callbacks = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : {};\n                  opts = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};\n                  params = {};\n                  if (opts && opts.id && typeof opts.id === \"string\" && opts.id.length === 64) params.id = opts.id;\n                  _context16.next = 6;\n                  return this.pollWebsocket('/poll/accounts', params, function (data) {\n                    if (callbacks && callbacks.onAccountUpdated) {\n                      if (!Array.isArray(data)) {\n                        data = [data];\n                      }\n\n                      data.forEach(function (item) {\n                        return callbacks.onAccountUpdated(item);\n                      });\n                    }\n                  });\n\n                case 6:\n                  return _context16.abrupt(\"return\", _context16.sent);\n\n                case 7:\n                case \"end\":\n                  return _context16.stop();\n              }\n            }\n          }, _callee16, this);\n        }));\n\n        function pollAccounts() {\n          return _pollAccounts.apply(this, arguments);\n        }\n\n        return pollAccounts;\n      }()\n      /**\n       * Poll for updates to either all transactions in the ledger, or transactions made by a certain sender, or\n       * transactions made by a certain creator, or transactions with a specific tag, or just a single transaction.\n       *\n       * @param callbacks\n       * @param {{id: string|undefined, tag: number|undefined, sender: string|undefined, creator: string|undefined}} opts\n       * @returns {Promise<WebSocketClient>} Websocket client.\n       */\n\n    }, {\n      key: \"pollTransactions\",\n      value: function () {\n        var _pollTransactions = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee17() {\n          var callbacks,\n              opts,\n              params,\n              _args17 = arguments;\n          return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n            while (1) {\n              switch (_context17.prev = _context17.next) {\n                case 0:\n                  callbacks = _args17.length > 0 && _args17[0] !== undefined ? _args17[0] : {};\n                  opts = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : {};\n                  params = {};\n                  if (opts && opts.id && typeof opts.id === \"string\" && opts.id.length === 64) params.id = opts.id;\n                  if (opts && opts.tag && typeof opts.tag === \"number\") params.tag = opts.tag;\n                  if (opts && opts.sender && typeof opts.sender === \"string\" && opts.sender.length === 64) params.sender = opts.sender;\n                  if (opts && opts.creator && typeof opts.creator === \"string\" && opts.creator.length === 64) params.creator = opts.creator;\n                  _context17.next = 9;\n                  return this.pollWebsocket('/poll/tx', params, function (data) {\n                    if (!Array.isArray(data)) {\n                      data = [data];\n                    }\n\n                    data.forEach(function (item) {\n                      switch (item.event) {\n                        case \"rejected\":\n                          if (callbacks && callbacks.onTransactionRejected) {\n                            callbacks.onTransactionRejected(item);\n                          }\n\n                          break;\n\n                        case \"applied\":\n                          if (callbacks && callbacks.onTransactionApplied) {\n                            callbacks.onTransactionApplied(item);\n                          }\n\n                          break;\n                      }\n                    });\n                  });\n\n                case 9:\n                  return _context17.abrupt(\"return\", _context17.sent);\n\n                case 10:\n                case \"end\":\n                  return _context17.stop();\n              }\n            }\n          }, _callee17, this);\n        }));\n\n        function pollTransactions() {\n          return _pollTransactions.apply(this, arguments);\n        }\n\n        return pollTransactions;\n      }()\n      /**\n       * Poll for finality of consensus rounds, or the pruning of consensus rounds.\n       *\n       * @param callbacks\n       * @returns {Promise<WebSocketClient>} Websocket client.\n       */\n\n    }, {\n      key: \"pollConsensus\",\n      value: function () {\n        var _pollConsensus = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee18() {\n          var callbacks,\n              _args18 = arguments;\n          return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n            while (1) {\n              switch (_context18.prev = _context18.next) {\n                case 0:\n                  callbacks = _args18.length > 0 && _args18[0] !== undefined ? _args18[0] : {};\n                  _context18.next = 3;\n                  return this.pollWebsocket('/poll/consensus', {}, function (data) {\n                    switch (data.event) {\n                      case \"round_end\":\n                        if (callbacks && callbacks.onRoundEnded) {\n                          callbacks.onRoundEnded(data);\n                        }\n\n                        break;\n\n                      case \"prune\":\n                        if (callbacks && callbacks.onRoundPruned) {\n                          callbacks.onRoundPruned(data);\n                        }\n\n                        break;\n                    }\n                  });\n\n                case 3:\n                  return _context18.abrupt(\"return\", _context18.sent);\n\n                case 4:\n                case \"end\":\n                  return _context18.stop();\n              }\n            }\n          }, _callee18, this);\n        }));\n\n        function pollConsensus() {\n          return _pollConsensus.apply(this, arguments);\n        }\n\n        return pollConsensus;\n      }()\n      /**\n       * A generic setup function for listening for websocket events from a Wavelet node.\n       *\n       * @param {string} endpoint Websocket endpoint.\n       * @param {Object=} params Query parameters to connect to the endpoint with.\n       * @param {Object=} callback Callback function for each new event from the websocket.\n       * @returns {Promise<WebSocketClient>} Websocket client.\n       */\n\n    }, {\n      key: \"pollWebsocket\",\n      value: function pollWebsocket(endpoint) {\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var info = url.parse(this.host);\n        info.protocol = info.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n        info.pathname = endpoint;\n        info.query = params;\n        return new Promise(function (resolve, reject) {\n          var client = new WebSocketClient(url.format(info));\n\n          client.onopen = function () {\n            resolve(client);\n          };\n\n          client.onerror = function () {\n            reject(new Error(\"Failed to connect to \".concat(url.format(info), \".\")));\n          };\n\n          client.onmessage = function (msg) {\n            if (typeof msg.data !== 'string') return;\n            if (callback) callback(JSON.parse(msg.data));\n          };\n        });\n      }\n      /**\n       * Randomly generate a new Wavelet wallet.\n       *\n       * @returns {nacl.SignKeyPair}\n       */\n\n    }], [{\n      key: \"generateNewWallet\",\n      value: function generateNewWallet() {\n        return nacl.sign.keyPair();\n      }\n      /**\n       * Load a Wavelet wallet given a hex-encoded private key.\n       *\n       * @param {string} private_key_hex Hex-encoded private key.\n       * @returns {nacl.SignKeyPair} Wavelet wallet.\n       */\n\n    }, {\n      key: \"loadWalletFromPrivateKey\",\n      value: function loadWalletFromPrivateKey(private_key_hex) {\n        return nacl.sign.keyPair.fromSecretKey(Buffer.from(private_key_hex, \"hex\"));\n      }\n      /**\n       * Parse a transactions payload content into JSON.\n       *\n       * @param {(TAG_NOP|TAG_TRANSFER|TAG_CONTRACT|TAG_STAKE|TAG_BATCH)} tag Tag of a transaction.\n       * @param {string} payload Binary-serialized payload of a transaction.\n       * @returns {{amount: bigint, recipient: string}|{}|Array|{amount: bigint}} Decoded payload of a transaction.\n       */\n\n    }, {\n      key: \"parseTransaction\",\n      value: function parseTransaction(tag, payload) {\n        switch (tag) {\n          case TAG_NOP:\n            {\n              return {};\n            }\n\n          case TAG_TRANSFER:\n            {\n              var buf = str2ab(atob(payload));\n\n              if (buf.byteLength < 32 + 8) {\n                throw new Error(\"transfer: payload does not contain recipient id or amount\");\n              }\n\n              var view = new DataView(buf);\n              var recipient = Buffer.from(new Uint8Array(buf, 0, 32)).toString('hex');\n              var amount = view.getBigUint64(32, true);\n              var tx = {\n                recipient: recipient,\n                amount: amount\n              };\n\n              if (buf.byteLength > 32 + 8) {\n                tx.gasLimit = view.getBigUint64(32 + 8, true);\n                tx.gasDeposit = view.getBigUint64(32 + 8 + 8, true);\n                var funcNameLen = view.getUint32(32 + 8 + 8 + 8, true);\n                tx.funcName = Buffer.from(new Uint8Array(buf, 32 + 8 + 8 + 8 + 4, funcNameLen)).toString(\"utf8\");\n                var funcPayloadLen = view.getUint32(32 + 8 + 8 + 8 + 4 + funcNameLen, true);\n                tx.payload = Buffer.from(new Uint8Array(buf, 32 + 8 + 8 + 8 + 4 + funcNameLen + 4, funcPayloadLen));\n              }\n\n              return tx;\n            }\n\n          case TAG_CONTRACT:\n            {\n              var _buf = str2ab(atob(payload));\n\n              if (_buf.byteLength < 12) {\n                throw new Error(\"contract: payload is malformed\");\n              }\n\n              var _view = new DataView(_buf);\n\n              var _tx = {};\n              _tx.gasLimit = _view.getBigUint64(0, true);\n              _tx.gasDeposit = _view.getBigUint64(8, true);\n\n              var payloadLen = _view.getUint32(8 + 8, true);\n\n              _tx.payload = Buffer.from(new Uint8Array(_buf, 8 + 8 + 4, payloadLen));\n              _tx.code = Buffer.from(new Uint8Array(_buf, 8 + 8 + 4 + payloadLen));\n              return _tx;\n            }\n\n          case TAG_STAKE:\n            {\n              var _buf2 = str2ab(atob(payload));\n\n              if (_buf2.byteLength !== 9) {\n                throw new Error(\"stake: payload must be exactly 9 bytes\");\n              }\n\n              var _view2 = new DataView(_buf2);\n\n              var opcode = _view2.getUint8(0);\n\n              if (opcode < 0 || opcode > 2) {\n                throw new Error(\"stake: opcode must be between 0 to 2\");\n              }\n\n              var _amount = _view2.getBigUint64(1, true);\n\n              var _tx2 = {\n                amount: _amount\n              };\n\n              switch (opcode) {\n                case 0:\n                  _tx2.op = \"withdraw_stake\";\n                  break;\n\n                case 1:\n                  _tx2.op = \"place_stake\";\n                  break;\n\n                case 2:\n                  _tx2.op = \"withdraw_reward\";\n                  break;\n              }\n\n              return _tx2;\n            }\n\n          case TAG_BATCH:\n            {\n              var _buf3 = str2ab(atob(payload));\n\n              var _view3 = new DataView(_buf3);\n\n              var len = _view3.getUint8(0);\n\n              var transactions = [];\n\n              for (var i = 0, offset = 1; i < len; i++) {\n                var _tag = _view3.getUint8(offset);\n\n                offset += 1;\n\n                var _payloadLen = _view3.getUint32(offset, true);\n\n                offset += 4;\n\n                var _payload2 = Buffer.from(new Uint8Array(_buf3, offset, _payloadLen));\n\n                offset += _payloadLen;\n                transactions.push(this.parseTransaction(_tag, _payload2));\n              }\n\n              return transactions;\n            }\n\n          default:\n            throw new Error(\"unknown tag type: \".concat(tag));\n        }\n      }\n    }]);\n\n    return Wavelet;\n  }();\n\n  var main = {\n    Wavelet: Wavelet,\n    Contract: Contract,\n    TAG_NOP: TAG_NOP,\n    TAG_TRANSFER: TAG_TRANSFER,\n    TAG_CONTRACT: TAG_CONTRACT,\n    TAG_STAKE: TAG_STAKE,\n    TAG_BATCH: TAG_BATCH\n  };\n  return main;\n});","map":null,"metadata":{},"sourceType":"script"}