{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/austinvuong/AuthentiCar/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('wavelet-client')) : typeof define === 'function' && define.amd ? define(['exports', 'react', 'wavelet-client'], factory) : (global = global || self, factory(global['react-use-wavelet'] = {}, global.react, global.waveletClient));\n})(this, function (exports, React, waveletClient) {\n  'use strict';\n\n  React = React && React.hasOwnProperty('default') ? React['default'] : React;\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function () {\n      var self = this,\n          args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(source, true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(source).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n  /**\n   * Connects to a Wavelet node\n   *\n   * @param {str} host Url of the host you wish to connect to\n   * @returns {[ WaveletClient, WaveletNode, Error ]} The Wavelet Client, Node info, and any errors returned\n   */\n\n\n  var useWavelet = function useWavelet(host) {\n    var _React$useState = React.useState(undefined),\n        _React$useState2 = _slicedToArray(_React$useState, 2),\n        client = _React$useState2[0],\n        setClient = _React$useState2[1];\n\n    var _React$useState3 = React.useState(undefined),\n        _React$useState4 = _slicedToArray(_React$useState3, 2),\n        node = _React$useState4[0],\n        setNodeInfo = _React$useState4[1];\n\n    var _React$useState5 = React.useState(undefined),\n        _React$useState6 = _slicedToArray(_React$useState5, 2),\n        error = _React$useState6[0],\n        setError = _React$useState6[1];\n\n    React.useEffect(function () {\n      var connect =\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee() {\n          var newClient;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  newClient = new waveletClient.Wavelet(host);\n                  _context.t0 = setNodeInfo;\n                  _context.next = 5;\n                  return newClient.getNodeInfo();\n\n                case 5:\n                  _context.t1 = _context.sent;\n                  (0, _context.t0)(_context.t1);\n                  setClient(newClient);\n                  setError(undefined);\n                  _context.next = 16;\n                  break;\n\n                case 11:\n                  _context.prev = 11;\n                  _context.t2 = _context[\"catch\"](0);\n                  setNodeInfo(undefined);\n                  setClient(undefined);\n                  setError(_context.t2);\n\n                case 16:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[0, 11]]);\n        }));\n\n        return function connect() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      if (host) {\n        connect();\n      }\n    }, [host]); // TODO: Add single listener for consensus events\n\n    return [client, node, error];\n  };\n  /**\n   * Fetches info of a Wavelet Account and listens to updates\n   *\n   * @param {WaveletClient} client client used for querying\n   * @param {string} privateKey 64 char hex encoded private key\n   * @returns {[ Account, Error ]} A reactive Account, and any errors returned\n   */\n\n\n  var useAccount = function useAccount(client, privateKey) {\n    var _React$useState7 = React.useState(undefined),\n        _React$useState8 = _slicedToArray(_React$useState7, 2),\n        account = _React$useState8[0],\n        setAccount = _React$useState8[1];\n\n    var _React$useState9 = React.useState(undefined),\n        _React$useState10 = _slicedToArray(_React$useState9, 2),\n        error = _React$useState10[0],\n        setError = _React$useState10[1];\n\n    var _React$useState11 = React.useState(undefined),\n        _React$useState12 = _slicedToArray(_React$useState11, 2),\n        accountSocket = _React$useState12[0],\n        setAccountSocket = _React$useState12[1];\n\n    var accountRef = React.useRef(account);\n    React.useEffect(function () {\n      accountRef.current = account;\n    }, [account]);\n    var accountSocketRef = React.useRef(accountSocket);\n    React.useEffect(function () {\n      accountSocketRef.current = accountSocket;\n    }, [accountSocket]);\n    React.useEffect(function () {\n      var reset = function reset() {\n        setAccount(undefined);\n\n        if (accountSocketRef.current) {\n          accountSocketRef.current.close(1000, 'closing account connection');\n        }\n\n        setAccountSocket(undefined);\n      };\n\n      var connect =\n      /*#__PURE__*/\n      function () {\n        var _ref2 = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee2() {\n          var wallet, walletAddress;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.prev = 0;\n                  wallet = waveletClient.Wavelet.loadWalletFromPrivateKey(privateKey);\n                  walletAddress = Buffer.from(wallet.publicKey).toString('hex');\n                  _context2.t0 = setAccount;\n                  _context2.next = 6;\n                  return client.getAccount(walletAddress);\n\n                case 6:\n                  _context2.t1 = _context2.sent;\n                  (0, _context2.t0)(_context2.t1);\n                  _context2.t2 = setAccountSocket;\n                  _context2.next = 11;\n                  return client.pollAccounts({\n                    onAccountUpdated: function onAccountUpdated(msg) {\n                      switch (msg.event) {\n                        case 'balance_updated':\n                          {\n                            setAccount(_objectSpread2({}, accountRef.current, {\n                              balance: msg.balance\n                            }));\n                            break;\n                          }\n\n                        default:\n                          {\n                            break;\n                          }\n                      }\n                    }\n                  }, {\n                    id: walletAddress\n                  });\n\n                case 11:\n                  _context2.t3 = _context2.sent;\n                  (0, _context2.t2)(_context2.t3);\n                  setError(undefined);\n                  _context2.next = 20;\n                  break;\n\n                case 16:\n                  _context2.prev = 16;\n                  _context2.t4 = _context2[\"catch\"](0);\n                  reset(); // Cannot throw due to react hook limitations\n\n                  setError(_context2.t4);\n\n                case 20:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[0, 16]]);\n        }));\n\n        return function connect() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      if (privateKey && client) {\n        connect();\n      } else {\n        reset();\n      }\n\n      return reset;\n    }, [client, privateKey]);\n    return [account, error];\n  };\n  /**\n   * This callback type is called `requestCallback` and is displayed as a global symbol.\n   *\n   * @callback contractCallback\n   * @param {Contract} contract Contract that can be interacted wit\n   */\n\n  /**\n   * Fetches and instantiates a Wavelet contract for interaction\n   *\n   * @param {WaveletClient} client client used for interacting with contract\n   * @param {string} contractAddress 64 char hex encoded contract address\n   * @param {contractCallback} onUpdate 64 char hex encoded contract address\n   * @param {contractCallback} onLoad 64 char hex encoded contract address\n   * @returns {[ Contract, Error ]} A reactive Contract, and any errors returned\n   */\n\n\n  var useContract = function useContract(client, contractAddress, onUpdate, onLoad) {\n    var _React$useState13 = React.useState(null),\n        _React$useState14 = _slicedToArray(_React$useState13, 2),\n        contract = _React$useState14[0],\n        setContract = _React$useState14[1];\n\n    var _React$useState15 = React.useState(null),\n        _React$useState16 = _slicedToArray(_React$useState15, 2),\n        consensusSocket = _React$useState16[0],\n        setConsensusSocket = _React$useState16[1];\n\n    var _React$useState17 = React.useState(undefined),\n        _React$useState18 = _slicedToArray(_React$useState17, 2),\n        error = _React$useState18[0],\n        setError = _React$useState18[1];\n\n    var consensusSocketRef = React.useRef(consensusSocket);\n    React.useEffect(function () {\n      consensusSocketRef.current = consensusSocket;\n    }, [consensusSocket]);\n    React.useEffect(function () {\n      var reset = function reset() {\n        if (consensusSocketRef.current) {\n          consensusSocketRef.current.close(1000, 'closing consensusSocket');\n        }\n\n        setConsensusSocket(undefined);\n        setContract(undefined);\n      };\n\n      var init =\n      /*#__PURE__*/\n      function () {\n        var _ref3 = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee3() {\n          var newContract;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.prev = 0;\n                  newContract = new waveletClient.Contract(client, contractAddress); // Initialize\n\n                  _context3.next = 4;\n                  return newContract.init();\n\n                case 4:\n                  _context3.next = 6;\n                  return newContract.fetchAndPopulateMemoryPages();\n\n                case 6:\n                  setContract(newContract);\n                  setError(undefined);\n                  _context3.next = 14;\n                  break;\n\n                case 10:\n                  _context3.prev = 10;\n                  _context3.t0 = _context3[\"catch\"](0);\n                  reset();\n                  setError(_context3.t0);\n\n                case 14:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, null, [[0, 10]]);\n        }));\n\n        return function init() {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n\n      if (!client) {\n        reset();\n      } else {\n        init();\n      }\n\n      return reset;\n    }, [client, contractAddress]);\n    React.useEffect(function () {\n      onLoad && contract && onLoad(contract);\n    }, [contract, onLoad]);\n    React.useEffect(function () {\n      var listen =\n      /*#__PURE__*/\n      function () {\n        var _ref4 = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee5() {\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  if (!(!client || !contract || !onUpdate)) {\n                    _context5.next = 2;\n                    break;\n                  }\n\n                  return _context5.abrupt(\"return\");\n\n                case 2:\n                  _context5.prev = 2;\n                  _context5.t0 = setConsensusSocket;\n                  _context5.next = 6;\n                  return client.pollConsensus({\n                    onRoundEnded: function onRoundEnded(_) {\n                      if (contract === undefined) {\n                        return;\n                      }\n\n                      _asyncToGenerator(\n                      /*#__PURE__*/\n                      _regeneratorRuntime.mark(function _callee4() {\n                        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                          while (1) {\n                            switch (_context4.prev = _context4.next) {\n                              case 0:\n                                _context4.next = 2;\n                                return contract.fetchAndPopulateMemoryPages();\n\n                              case 2:\n                                onUpdate(contract);\n\n                              case 3:\n                              case \"end\":\n                                return _context4.stop();\n                            }\n                          }\n                        }, _callee4);\n                      }))();\n                    }\n                  });\n\n                case 6:\n                  _context5.t1 = _context5.sent;\n                  (0, _context5.t0)(_context5.t1);\n                  _context5.next = 13;\n                  break;\n\n                case 10:\n                  _context5.prev = 10;\n                  _context5.t2 = _context5[\"catch\"](2);\n                  setError(_context5.t2);\n\n                case 13:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, null, [[2, 10]]);\n        }));\n\n        return function listen() {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n\n      listen();\n      return function () {\n        if (consensusSocketRef.current) {\n          consensusSocketRef.current.close(1000, 'closing consensusSocket');\n        }\n\n        setConsensusSocket(undefined);\n      };\n    }, [client, contract, onUpdate]);\n    return [contract, error];\n  };\n\n  exports.useAccount = useAccount;\n  exports.useContract = useContract;\n  exports.useWavelet = useWavelet;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}